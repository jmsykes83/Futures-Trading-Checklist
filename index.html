<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Futures Trade Checklist</title>
    <style>
        /* Global Box-Sizing for consistent layout across browsers */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* CSS Variables for theming */
        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --container-bg: rgba(255, 255, 255, 0.95);
            --container-shadow: rgba(0,0,0,0.1);
            --category-bg-gradient-start: #f8f9ff;
            --category-bg-gradient-end: #e8f0ff;
            --category-border: #e0e8ff;
            --heading-color: #4a5568;
            --text-color: #2d3748;
            --label-color: #2d3748;
            --input-accent-color: #667eea;
            --checklist-item-hover-bg: rgba(255,255,255,0.7);
            --notes-border: #e2e8f0;
            --notes-focus-border: #667eea;
            --notes-focus-shadow: rgba(102, 126, 234, 0.1);
            --risk-card-bg-gradient-start: #f0f7ff;
            --risk-card-bg-gradient-end: #e0f0ff;
            --risk-card-border-left: #667eea;
            --risk-reward-display-bg-gradient-start: #e6fffa;
            --risk-reward-display-bg-gradient-end: #b2f5ea;
            --risk-reward-display-border: #81e6d9;
            --good-ratio-color: #38a169;
            --bad-ratio-color: #e53e3e;
            --filter-button-bg: #cbd5e0;
            --filter-button-color: #2d3748;
            --filter-button-hover-bg: #a0aec0;
            --filter-button-active-bg: #667eea;
            --filter-button-active-color: white;
            --filter-button-active-shadow: rgba(102, 126, 234, 0.3);
            --details-bg: rgba(255, 255, 255, 0.6);
            --details-border: #e0e8ff;
            --details-open-bg: rgba(255, 255, 255, 0.8);
            --details-open-shadow: rgba(0,0,0,0.08);

            /* Modal specific colors */
            --modal-overlay-bg: rgba(0, 0, 0, 0.5);
            --modal-content-bg: white;
            --modal-border-color: #e2e8f0;
            --modal-title-color: #2d3748;
            --modal-message-color: #4a5568;
            --modal-button-confirm-bg: #38a169;
            --modal-button-confirm-hover-bg: #2f855a;
            --modal-button-cancel-bg: #e53e3e;
            --modal-button-cancel-hover-bg: #c53030;
            --modal-button-ok-bg: #4299e1;
            --modal-button-ok-hover-bg: #3182ce;

            /* Share/Import Modal Specific */
            --tab-button-bg: #e2e8f0;
            --tab-button-color: #2d3748;
            --tab-button-active-bg: #667eea;
            --tab-button-active-color: white;
            --tab-content-bg: #f7fafc;
            --textarea-border: #cbd5e0;
            --textarea-focus-border: #667eea;
            --copy-button-bg: #4299e1;
            --copy-button-hover-bg: #3182ce;

            /* GitHub Link */
            --github-link-color: #4a5568;
            --github-link-hover-color: #667eea;

            /* Input fields in modals */
            --modal-input-bg: #f0f0f0;
            --modal-input-border: #ccc;
            --modal-input-focus-border: #667eea;
            --modal-input-color: #2d3748;
        }

        /* Dark Mode */
        body.dark-mode {
            --bg-gradient-start: #2d3748;
            --bg-gradient-end: #1a202c;
            --container-bg: rgba(45, 55, 72, 0.95);
            --container-shadow: rgba(0,0,0,0.5);
            --category-bg-gradient-start: #4a5568;
            --category-bg-gradient-end: #2d3748;
            --category-border: #2c374e;
            --heading-color: #e2e8f0;
            --text-color: #e2e8f0;
            --label-color: #e2e8f0;
            --input-accent-color: #4299e1;
            --checklist-item-hover-bg: rgba(74,85,104,0.7);
            --notes-border: #4a5568;
            --notes-focus-border: #4299e1;
            --notes-focus-shadow: rgba(66, 153, 225, 0.2);
            --risk-card-bg-gradient-start: #2d3748;
            --risk-card-bg-gradient-end: #1a202c;
            --risk-card-border-left: #4299e1;
            --risk-reward-display-bg-gradient-start: #2a4365;
            --risk-reward-display-bg-gradient-end: #1a365d;
            --risk-reward-display-border: #4299e1;
            --good-ratio-color: #68d391;
            --bad-ratio-color: #fc8181;
            --filter-button-bg: #4a5568;
            --filter-button-color: #e2e8f0;
            --filter-button-hover-bg: #667eea;
            --filter-button-active-bg: #4299e1;
            --filter-button-active-color: white;
            --filter-button-active-shadow: rgba(66, 153, 225, 0.3);
            --details-bg: rgba(45, 55, 72, 0.6);
            --details-border: #2c374e;
            --details-open-bg: rgba(45, 55, 72, 0.8);
            --details-open-shadow: rgba(0,0,0,0.2);

            /* Modal specific colors for dark mode */
            --modal-overlay-bg: rgba(0, 0, 0, 0.7);
            --modal-content-bg: #2d3748;
            --modal-border-color: #4a5568;
            --modal-title-color: #e2e8f0;
            --modal-message-color: #cbd5e0;
            --modal-button-confirm-bg: #48bb78;
            --modal-button-confirm-hover-bg: #38a169;
            --modal-button-cancel-bg: #fc8181;
            --modal-button-cancel-hover-bg: #e53e3e;
            --modal-button-ok-bg: #63b3ed;
            --modal-button-ok-hover-bg: #4299e1;

            /* Share/Import Modal Specific Dark Mode */
            --tab-button-bg: #4a5568;
            --tab-button-color: #e2e8f0;
            --tab-button-active-bg: #4299e1;
            --tab-button-active-color: white;
            --tab-content-bg: #1a202c;
            --textarea-border: #4a5568;
            --textarea-focus-border: #4299e1;
            --copy-button-bg: #63b3ed;
            --copy-button-hover-bg: #4299e1;

            /* GitHub Link Dark Mode */
            --github-link-color: #e2e8f0;
            --github-link-hover-color: #63b3ed;

            /* Input fields in modals Dark Mode */
            --modal-input-bg: #3a4454;
            --modal-input-border: #5a6474;
            --modal-input-focus-border: #63b3ed;
            --modal-input-color: #e2e8f0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            margin: 0;
            color: var(--text-color); /* Apply base text color */
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .checklist-container {
            background: var(--container-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px var(--container-shadow);
            margin-bottom: 20px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            position: relative; /* For placeholder positioning if needed */
            min-height: 100px; /* Example to ensure drop area exists */
        }
        
        .category {
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(145deg, var(--category-bg-gradient-start), var(--category-bg-gradient-end));
            border: 1px solid var(--category-border);
            border-radius: 12px;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.3s ease, border-color 0.3s ease;
            cursor: grab; /* Indicate draggable */
        }
        
        .category:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--container-shadow);
        }

        .category.dragging {
            opacity: 0.5;
            border: 2px dashed var(--input-accent-color);
            cursor: grabbing;
        }

        .category-placeholder {
            /* Dynamically set height in JS, basic styling here */
            background-color: rgba(0,0,0,0.05);
            border: 2px dashed #aaa;
            border-radius: 12px;
            margin-bottom: 20px; /* Should match .category margin-bottom */
            /* Ensure other layout-affecting properties match .category if needed */
        }
        
        .category h3 {
            margin: 0 0 12px 0;
            color: var(--heading-color);
            font-size: 1.2em;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            transition: color 0.3s ease;
        }
        
        .category-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .add-criteria-mini {
            background: var(--input-accent-color);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .add-criteria-mini:hover {
            background: var(--filter-button-active-bg); /* Use active filter color for hover */
            transform: scale(1.1);
        }
        
        .category-icon {
            font-size: 1.1em;
        }
        
        .checklist-item {
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Added this to allow items to wrap */
            margin: 8px 0;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
            position: relative; /* Needed for absolute positioning of delete button */
        }
        
        .checklist-item:hover {
            background-color: var(--checklist-item-hover-bg);
        }
        
        .checklist-item input {
            margin-right: 12px;
            transform: scale(1.2);
            accent-color: var(--input-accent-color);
            transition: accent-color 0.3s ease;
        }

        /* Animation for checkbox check/uncheck */
        .checklist-item input[type="checkbox"] {
            position: relative;
            cursor: pointer;
        }

        .checklist-item input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: transparent;
            border-radius: 4px;
            transition: background-color 0.2s ease-out;
        }

        .checklist-item input[type="checkbox"]:checked::before {
            background-color: var(--input-accent-color);
            transform: scale(1.1); /* Slight pop effect */
            opacity: 0.2;
        }
        
        .checklist-item label {
            cursor: pointer;
            flex-grow: 1;
            font-weight: 500;
            color: var(--label-color);
            transition: color 0.3s ease;
        }
        
        .strategy-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-left: auto;
        }
        
        .strategy-badge {
            background: var(--input-accent-color); /* Default badge color */
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 500;
        }
        
        .strategy-badge.reversal {
            background: #e53e3e;
        }
        
        .strategy-badge.momentum {
            background: #38a169;
        }
        
        .strategy-badge.both {
            background: linear-gradient(45deg, #e53e3e, #38a169);
        }
        .strategy-badge.scalping { background: #9F7AEA; } /* Purple */
        .strategy-badge.swing { background: #3182CE; } /* Blue */
        .strategy-badge.breakout { background: #DD6B20; } /* Orange */
        
        .result {
            font-size: 1.3em;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            border-radius: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            color: var(--text-color);
        }
        
        .result.waiting {
            background: linear-gradient(145deg, var(--category-bg-gradient-start), var(--category-bg-gradient-end));
            color: var(--heading-color);
            border: 2px solid var(--category-border);
        }
        
        .result.ready {
            background: linear-gradient(145deg, var(--good-ratio-color), #9ae6b4); /* Adjusted for dark mode */
            color: var(--text-color); /* Adjusted for dark mode */
            border: 2px solid var(--good-ratio-color);
            animation: pulse 2s infinite;
        }
        
        .result.warning {
            background: linear-gradient(145deg, var(--bad-ratio-color), #feb2b2); /* Adjusted for dark mode */
            color: var(--text-color); /* Adjusted for dark mode */
            border: 2px solid var(--bad-ratio-color);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .notes-section {
            background: var(--container-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px var(--container-shadow);
            margin-top: 20px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }
        
        .notes-section h2 {
            color: var(--heading-color);
            margin-bottom: 15px;
            transition: color 0.3s ease;
        }
        
        .notes-section textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            font-size: 1em;
            border: 2px solid var(--notes-border);
            border-radius: 12px;
            resize: vertical;
            font-family: inherit;
            transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
            background-color: transparent; /* Allow background to show through */
            color: var(--text-color);
        }
        
        .notes-section textarea:focus {
            outline: none;
            border-color: var(--notes-focus-border);
            box-shadow: 0 0 0 3px var(--notes-focus-shadow);
        }
        
        /* Updated styles for action and filter buttons */
        .action-buttons {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap to next line */
            gap: 10px; /* Increased gap for better spacing */
            margin-bottom: 20px;
            justify-content: center; /* Center buttons */
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px; /* Space from summary */
            justify-content: center;
        }

        .filter-button {
            background: var(--filter-button-bg);
            color: var(--filter-button-color);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }

        .filter-button:hover {
            background: var(--filter-button-hover-bg);
            transform: translateY(-1px);
        }

        .filter-button.active {
            background: var(--filter-button-active-bg);
            color: var(--filter-button-active-color);
            box-shadow: 0 4px 10px var(--filter-button-active-shadow);
        }

        .add-criteria-btn { /* This class is used for multiple action buttons */
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .add-criteria-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--filter-button-active-shadow);
        }
        
        .custom-criteria {
            background: linear-gradient(145deg, #fff5f5, #ffe5e5); /* Keep distinct light background for custom */
            border: 1px solid #feb2b2;
        }
        body.dark-mode .custom-criteria {
            background: linear-gradient(145deg, #3a2a2a, #4a3a3a); /* Dark mode for custom criteria */
            border: 1px solid #a00000;
        }
        
        .risk-management {
            background: var(--container-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 10px 30px var(--container-shadow);
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }
        
        .risk-management h2 {
            color: var(--heading-color);
            transition: color 0.3s ease;
        }

        .risk-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .risk-card {
            background: linear-gradient(145deg, var(--risk-card-bg-gradient-start), var(--risk-card-bg-gradient-end));
            padding: 15px;
            border-radius: 12px;
            border-left: 4px solid var(--risk-card-border-left);
            transition: background 0.3s ease, border-color 0.3s ease;
        }
        
        .risk-card h4 {
            margin: 0 0 8px 0;
            color: var(--heading-color);
            font-size: 1.1em;
            transition: color 0.3s ease;
        }
        
        .risk-card p {
            margin: 0;
            color: var(--label-color);
            font-size: 0.9em;
            transition: color 0.3s ease;
            position: relative; /* For tooltip positioning */
        }

        .delete-criteria-btn, .edit-criteria-btn {
            background: #e53e3e; /* Red for delete */
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
            margin-left: 10px; /* Space from badges */
            flex-shrink: 0;
        }
        .edit-criteria-btn {
            background: #4299e1; /* Blue for edit */
            margin-left: 5px; /* Closer to the item */
        }

        .delete-criteria-btn:hover {
            background: #c53030; /* Darker red on hover */
            transform: scale(1.1);
        }
        .edit-criteria-btn:hover {
            background: #3182ce; /* Darker blue on hover */
            transform: scale(1.1);
        }

        .risk-reward-display {
            background: linear-gradient(145deg, var(--risk-reward-display-bg-gradient-start), var(--risk-reward-display-bg-gradient-end));
            color: var(--text-color);
            padding: 15px 20px;
            border-radius: 15px;
            margin-top: 20px;
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            box-shadow: 0 8px 25px var(--container-shadow);
            border: 2px solid var(--risk-reward-display-border);
            transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        .risk-reward-display span {
            color: var(--good-ratio-color); /* Green for good ratio */
            font-size: 1.2em;
            transition: color 0.3s ease;
        }
        .risk-reward-display.bad-ratio span {
            color: var(--bad-ratio-color); /* Red for bad ratio */
        }

        details {
            margin-top: 10px;
            padding: 10px;
            background: var(--details-bg);
            border-radius: 8px;
            border: 1px solid var(--details-border);
            transition: all 0.2s ease, background 0.3s ease, border-color 0.3s ease;
        }
        details[open] {
            background: var(--details-open-bg);
            box-shadow: 0 4px 15px var(--details-open-shadow);
        }
        summary {
            font-weight: 600;
            color: var(--heading-color);
            cursor: pointer;
            padding: 5px 0;
            outline: none;
            list-style: none; /* Remove default arrow */
            display: flex;
            align-items: center;
            transition: color 0.3s ease;
        }
        summary::-webkit-details-marker {
            display: none; /* Remove default arrow for Webkit browsers */
        }
        summary::before {
            content: '▶'; /* Custom arrow */
            margin-right: 8px;
            transition: transform 0.2s ease;
        }
        details[open] summary::before {
            content: '▼'; /* Custom arrow when open */
            transform: rotate(0deg);
        }

        .dark-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--filter-button-bg);
            color: var(--filter-button-color);
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .dark-mode-toggle:hover {
            background: var(--filter-button-hover-bg);
            transform: translateY(-1px);
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interactions when hidden */
        }
        .modal-content {
            background: var(--modal-content-bg);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--modal-border-color);
            transition: background 0.3s ease, border-color 0.3s ease;
        }
        .modal-content h3 {
            color: var(--modal-title-color);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.4em;
            transition: color 0.3s ease;
        }
        .modal-content p {
            color: var(--modal-message-color);
            margin-bottom: 25px;
            line-height: 1.5;
            transition: color 0.3s ease;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .modal-button.confirm {
            background-color: var(--modal-button-confirm-bg);
        }
        .modal-button.confirm:hover {
            background-color: var(--modal-button-confirm-hover-bg);
            transform: translateY(-1px);
        }
        .modal-button.cancel {
            background-color: var(--modal-button-cancel-bg);
        }
        .modal-button.cancel:hover {
            background-color: var(--modal-button-cancel-hover-bg);
            transform: translateY(-1px);
        }
        .modal-button.ok {
            background-color: var(--modal-button-ok-bg);
        }
        .modal-button.ok:hover {
            background-color: var(--modal-button-ok-hover-bg);
            transform: translateY(-1px);
        }

        /* Tooltip Styles */
        .tooltip-box {
            position: absolute;
            background-color: var(--modal-content-bg);
            color: var(--text-color);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            max-width: 250px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 100;
            pointer-events: none; /* Allows clicks through the tooltip */
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translateY(5px);
            border: 1px solid var(--modal-border-color);
            text-align: left;
        }

        .tooltip-box.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip-box::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid var(--modal-content-bg);
            top: -8px;
            left: 15px;
        }
        body.dark-mode .tooltip-box::before {
            border-bottom-color: var(--modal-content-bg);
        }

        /* Share/Import Modal Specific Styles */
        .share-import-modal .modal-content {
            max-width: 600px;
        }

        .tab-buttons {
            display: flex;
            margin-bottom: 20px;
        }

        .tab-button {
            flex-grow: 1;
            padding: 10px 15px;
            background-color: var(--tab-button-bg);
            color: var(--tab-button-color);
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .tab-button:hover {
            background-color: var(--filter-button-hover-bg);
        }

        .tab-button.active {
            background-color: var(--tab-button-active-bg);
            color: var(--tab-button-active-color);
        }

        .tab-content {
            background-color: var(--tab-content-bg);
            padding: 20px;
            border-radius: 0 0 15px 15px;
            border: 1px solid var(--modal-border-color);
            text-align: left;
            min-height: 150px;
            display: none; /* Hidden by default */
        }
        .tab-content.active {
            display: block; /* Show active tab */
        }

        /* NEW: Sub-tab content styles for Share/Import tab */
        .sub-tab-content {
            display: none; /* Hidden by default */
            padding: 15px;
            border: 1px solid var(--modal-border-color);
            border-radius: 8px; /* Slightly rounded corners for sub-tabs */
            background-color: var(--tab-content-bg);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            margin-top: 10px; /* Space from sub-tab buttons */
        }
        .sub-tab-content.active {
            display: block; /* Show active sub-tab */
        }


        .tab-content label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--label-color);
        }

        .tab-content textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid var(--textarea-border);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9em;
            resize: vertical;
            background-color: transparent; /* Allow background to show through */
            color: var(--text-color);
            transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
        }
        .tab-content textarea:focus {
            outline: none;
            border-color: var(--textarea-focus-border);
            box-shadow: 0 0 0 2px var(--notes-focus-shadow);
        }

        .tab-content button {
            margin-top: 15px;
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .tab-content button.generate-button {
            background-color: var(--copy-button-bg);
        }
        .tab-content button.generate-button:hover {
            background-color: var(--copy-button-hover-bg);
            transform: translateY(-1px);
        }
        .tab-content button.copy-button {
            background-color: var(--copy-button-bg);
            margin-left: 10px;
        }
        .tab-content button.copy-button:hover {
            background-color: var(--copy-button-hover-bg);
            transform: translateY(-1px);
        }
        .tab-content button.import-button {
            background-color: var(--modal-button-confirm-bg);
        }
        .tab-content button.import-button:hover {
            background-color: var(--modal-button-confirm-hover-bg);
            transform: translateY(-1px);
        }

        .github-link-section {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            background: var(--container-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 10px 30px var(--container-shadow);
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        .github-link-section a {
            color: var(--github-link-color);
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1em;
            transition: color 0.2s ease, transform 0.2s ease;
            display: inline-block; /* Allows transform */
        }

        .github-link-section a:hover {
            color: var(--github-link-hover-color);
            transform: translateY(-2px);
            text-decoration: underline;
        }

        /* New Modal for Add/Edit Strategy/Criteria */
        .input-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--label-color);
        }

        .input-group input[type="text"],
        .input-group input[type="number"],
        .input-group input[type="color"],
        .input-group textarea,
        .input-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--modal-input-border);
            border-radius: 8px;
            font-size: 1em;
            background-color: var(--modal-input-bg);
            color: var(--modal-input-color);
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease;
        }

        .input-group input:focus,
        .input-group textarea:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--modal-input-focus-border);
            box-shadow: 0 0 0 2px var(--notes-focus-shadow);
        }

        .input-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        .input-group select {
            appearance: none; /* Remove default select arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%20viewBox%3D%220%200%20292.4%20292.4%22%3E%3Cpath%20fill%3D%22%232d3748%22%20d%3D%22M287%2C197.971L159.268%2C69.256c-3.793-3.694-9.972-3.694-13.765%2C0L5.329%2C197.971c-3.793%2C3.694-3.793%2C9.668%2C0%2C13.362l13.765%2C13.362c3.793%2C3.694%2C9.972%2C3.694%2C13.765%2C0L146.4%2C101.441l113.141%2C113.254c3.793%2C3.694%2C9.972%2C3.694%2C13.765%2C0l13.765%2C-13.362C290.793%2C207.639%2C290.793%2C201.665%2C287%2C197.971z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px; /* Make space for the custom arrow */
        }
        body.dark-mode .input-group select {
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%20viewBox%3D%220%200%20292.4%20292.4%22%3E%3Cpath%20fill%3D%22%23e2e8f0%22%20d%3D%22M287%2C197.971L159.268%2C69.256c-3.793-3.694-9.972-3.694-13.765%2C0L5.329%2C197.971c-3.793%2C3.694-3.793%2C9.668%2C0%2C13.362l13.765%2C13.362c3.793%2C3.694%2C9.972%2C3.694%2C13.765%2C0L146.4%2C101.441l113.141%2C113.254c3.793%2C3.694%2C9.972%2C3.694%2C13.765%2C0l13.765%2C-13.362C290.793%2C207.639%2C290.793%2C201.665%2C287%2C197.971z%22%2F%3E%3C%2Fsvg%3E');
        }

        .modal-form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .modal-form-grid .input-group {
            margin-bottom: 0; /* Remove default margin from input-group */
        }
        /* Removed .full-width as per user request for entryPrice */

        .pnl-display {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-color);
        }
        .pnl-display .profit {
            color: var(--good-ratio-color);
            position: relative; /* For tooltip positioning */
        }
        .pnl-display .loss {
            color: var(--bad-ratio-color);
            position: relative; /* For tooltip positioning */
        }

    </style>
</head>
<body>
    <div class="container">
        <button class="dark-mode-toggle" id="darkModeToggle">
            ☀️ Light Mode
        </button>

        <h1>🎯 Futures Trade Checklist</h1>

        <div class="checklist-container">
            <div class="action-buttons">
                <button class="add-criteria-btn" onclick="openManageStrategiesModal()" style="background: linear-gradient(145deg, #ed8936, #dd6b20);">⚙️ Manage Strategies</button>
                <button class="add-criteria-btn" onclick="openManageCategoriesModal()" style="background: linear-gradient(145deg, #4299e1, #3182ce);">🗄️ Manage Categories</button>
                <button class="add-criteria-btn" onclick="openManageLayoutsModal()">🗂️ Manage Layouts</button>
                <button class="add-criteria-btn" onclick="resetCheckedCriteria()" style="background: linear-gradient(145deg, #f56565, #e53e3e);">🔄 Reset Checks</button>
            </div>

            <details class="filter-details">
                <summary>Filter Strategies</summary>
                <div class="filter-buttons" id="strategy-filters">
                </div>
            </details>
            
            <!-- 
            <div class="category" data-group="levels" draggable="true">
                <h3> ... </h3>
                <div class="checklist-item"> ... </div>
            </div>
            -->
        </div>

        <div class="result waiting" id="result">Select criteria to identify your trade setup...</div>
        <div class="risk-reward-display" id="risk-reward-display">Risk:Reward Ratio: <span>N/A</span></div>

        <div class="risk-management">
            <h2>🎯 Risk Management</h2>
            <div class="risk-info">
                <div class="risk-card">
                    <h4>Calculated Risk (Sum of Checked Criteria)</h4>
                    <p id="calculated-risk" data-info="This is the sum of the 'Risk Value' for all checked criteria. It represents the total relative risk points for your trade setup.">N/A</p>
                </div>
                <div class="risk-card">
                    <h4>Calculated Reward (Sum of Checked Criteria)</h4>
                    <p id="calculated-reward" data-info="This is the sum of the 'Reward Value' for all checked criteria. It represents the total relative reward points for your trade setup.">N/A</p>
                </div>
                <div class="risk-card">
                    <h4>Suggested Stop (Dominant Strategy)</h4>
                    <p id="suggested-stop">Based on selected criteria</p>
                </div>
                <div class="risk-card">
                    <h4>Suggested Target (Dominant Strategy)</h4>
                    <p id="suggested-target">Based on selected criteria</p>
                </div>
            </div>
            <div class="notes-section" style="padding: 20px; margin-top: 20px;">
                <h2>💵 P&L Calculation</h2>
                <div class="modal-form-grid">
                    <div class="input-group">
                        <label for="tradeSize">Trade Size (Contracts/Lots):</label>
                        <input type="number" id="tradeSize" value="1" min="0.1" step="0.1" oninput="saveState(); updateChecklistState();">
                    </div>
                    <div class="input-group">
                        <label for="tickValue">Tick Value (per contract):</label>
                        <input type="number" id="tickValue" value="5.00" min="0.01" step="0.01" oninput="saveState(); updateChecklistState();">
                    </div>
                    <div class="input-group">
                        <label for="futuresTickSize">Futures Tick Size (points):</label>
                        <input type="number" id="futuresTickSize" value="0.25" min="0.01" step="0.01" oninput="saveState(); updateChecklistState();">
                    </div>
                    <div class="input-group">
                        <label for="entryPrice">Entry Price (for context):</label>
                        <input type="number" id="entryPrice" value="0.00" min="0" step="0.01" oninput="saveState(); updateChecklistState();">
                    </div>
                </div>
                <div class="pnl-display">
                    <p>Potential Loss: <span id="potentialLoss" class="loss">N/A</span></p>
                    <p>Potential Profit: <span id="potentialProfit" class="profit">N/A</span></p>
                </div>
            </div>
        </div>

        <div class="notes-section">
            <h2>📝 Trade Setup Notes</h2>
            <textarea id="trade-notes" placeholder="Document your trade setup, key levels, and observations here..."></textarea>
        </div>

        <div class="github-link-section">
            <a href="https://github.com/jmsykes83/Futures-Trading-Checklist.git" target="_blank" rel="noopener noreferrer">
                View Source Code on GitHub
            </a>
        </div>
    </div>

    <div id="customModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <div id="modalInputContainer" class="input-group" style="display: none;">
                <label for="modalInput" id="modalInputLabel"></label>
                <input type="text" id="modalInput">
            </div>
            <div class="modal-buttons">
                <button id="modalConfirmBtn" class="modal-button confirm">Confirm</button>
                <button id="modalCancelBtn" class="modal-button cancel">Cancel</button>
                <button id="modalOkBtn" class="modal-button ok">OK</button>
            </div>
        </div>
    </div>

    <div id="manageStrategiesModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Manage Strategies</h3>
            <div id="strategyListContainer">
                </div>
            <div style="margin-top: 20px;">
                <button class="modal-button confirm" onclick="openAddStrategyModal()">+ Add New Strategy</button>
                <button class="modal-button cancel" onclick="closeManageStrategiesModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="addEditStrategyModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="addEditStrategyTitle"></h3>
            <div class="input-group">
                <label for="strategyIdInput">Strategy ID (lowercase, no spaces):</label>
                <input type="text" id="strategyIdInput" placeholder="e.g., momentum_scalping">
            </div>
            <div class="input-group">
                <label for="strategyNameInput">Display Name:</label>
                <input type="text" id="strategyNameInput" placeholder="e.g., Momentum Scalping">
            </div>
            <div class="input-group">
                <label for="strategyColorInput">Color:</label>
                <input type="color" id="strategyColorInput" value="#3182ce">
            </div>
            <div class="input-group">
                <label for="strategyIconInput">Emoji Icon:</label>
                <input type="text" id="strategyIconInput" placeholder="e.g., ⚡">
            </div>
            <div class="modal-form-grid">
                <div class="input-group">
                    <label for="strategyDefaultRiskInput">Default Risk Value:</label>
                    <input type="number" id="strategyDefaultRiskInput" value="1.0" step="0.1">
                </div>
                <div class="input-group">
                    <label for="strategyDefaultRewardInput">Default Reward Value:</label>
                    <input type="number" id="strategyDefaultRewardInput" value="1.0" step="0.1">
                </div>
            </div>
            <div class="input-group full-width">
                <label for="strategyDefaultStopInput">Default Stop Description:</label>
                <input type="text" id="strategyDefaultStopInput" placeholder="e.g., Bar trail / VWAP break">
            </div>
            <div class="input-group full-width">
                <label for="strategyDefaultTargetInput">Default Target Description:</label>
                <input type="text" id="strategyDefaultTargetInput" placeholder="e.g., Gas out (L2/T&S slowdown)">
            </div>
            <div class="modal-buttons">
                <button class="modal-button confirm" id="saveStrategyBtn">Save Strategy</button>
                <button class="modal-button cancel" onclick="closeAddEditStrategyModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="addEditCriteriaModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="addEditCriteriaTitle"></h3>
            <div class="input-group">
                <label for="criteriaNameInput">Criteria Name:</label>
                <input type="text" id="criteriaNameInput" placeholder="e.g., Weakening volume into level">
            </div>
            <div class="input-group">
                <label for="criteriaCategorySelect">Category:</label>
                <select id="criteriaCategorySelect"></select>
            </div>
            <div class="input-group">
                <label for="criteriaStrategiesInput">Strategies (comma-separated IDs):</label>
                <input type="text" id="criteriaStrategiesInput" placeholder="e.g., reversal,momentum">
                <small style="color: var(--modal-message-color); font-size: 0.8em; display: block; margin-top: 5px;">Available: <span id="availableStrategiesHint"></span></small>
            </div>
            <div class="modal-form-grid">
                <div class="input-group">
                    <label for="criteriaRiskInput">Risk Value:</label>
                    <input type="number" id="criteriaRiskInput" value="1.0" step="0.1">
                </div>
                <div class="input-group">
                    <label for="criteriaRewardInput">Reward Value:</label>
                    <input type="number" id="criteriaRewardInput" value="1.0" step="0.1">
                </div>
            </div>
            <div class="input-group full-width">
                <label for="criteriaInfoInput">Tooltip Information (optional):</label>
                <textarea id="criteriaInfoInput" placeholder="Detailed explanation for this criteria..."></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-button confirm" id="saveCriteriaBtn">Save Criteria</button>
                <button class="modal-button cancel" onclick="closeAddEditCriteriaModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="manageLayoutsModal" class="modal-overlay hidden">
        <div class="modal-content share-import-modal"> <h3>Manage Layouts</h3>
            <div class="tab-buttons">
                <button class="tab-button active" data-layout-tab="saved">Saved Layouts</button>
                <button class="tab-button" data-layout-tab="share-import">Share/Import</button>
                <button class="tab-button" data-layout-tab="default">Default Layout</button>
            </div>
            
            <div id="savedLayoutsTab" class="tab-content active">
                <p style="text-align: center; color: var(--modal-message-color);">Your saved checklist configurations.</p>
                <div id="layoutListContainer" style="max-height: 200px; overflow-y: auto; margin-bottom: 20px; border: 1px solid var(--modal-border-color); border-radius: 8px; padding: 10px;">
                    </div>
                <div style="text-align: center;">
                    <button class="modal-button confirm" onclick="saveCurrentLayout()">💾 Save Current Layout</button>
                </div>
            </div>
            
            <div id="shareImportLayoutTab" class="tab-content">
                <div class="tab-buttons" style="margin-bottom: 10px;">
                    <button class="tab-button active" data-sub-tab="export">Export</button>
                    <button class="tab-button" data-sub-tab="import">Import</button>
                </div>
                <div id="exportSubTab" class="sub-tab-content active">
                    <p>Generate a code to share your current custom strategies, custom criteria, and checked items.</p>
                    <button class="generate-button" id="generateCodeBtnLayout">Generate Share Code</button>
                    <textarea id="shareCodeOutputLayout" readonly placeholder="Your share code will appear here..."></textarea>
                    <button class="copy-button" id="copyCodeBtnLayout">Copy Code</button>
                </div>
                <div id="importSubTab" class="sub-tab-content">
                    <p>Paste a share code here to load new settings. This will **overwrite** your current custom strategies, custom criteria, and checked items.</p>
                    <textarea id="importCodeInputLayout" placeholder="Paste share code here..."></textarea>
                    <button class="import-button" id="importCodeBtnLayout">Import Settings</button>
                </div>
            </div>

            <div id="defaultLayoutTab" class="tab-content">
                <p style="text-align: center; color: var(--modal-message-color);">Load the original default checklist layout. This will **overwrite** all your custom strategies, criteria, and saved layouts.</p>
                <div style="text-align: center;">
                    <button class="modal-button cancel" onclick="loadDefaultLayout()">🏠 Load Default Layout</button>
                </div>
            </div>

            <div style="text-align: right; margin-top: 20px;">
                <button class="modal-button cancel" onclick="closeManageLayoutsModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="manageCategoriesModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Manage Categories</h3>
            <div id="categoryListContainer">
                </div>
            <div style="margin-top: 20px;">
                <button class="modal-button confirm" onclick="openAddCategoryModal()">+ Add New Category</button>
                <button class="modal-button cancel" onclick="closeManageCategoriesModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="addEditCategoryModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="addEditCategoryTitle"></h3>
            <div class="input-group">
                <label for="categoryIdInput">Category ID (lowercase, no spaces):</label>
                <input type="text" id="categoryIdInput" placeholder="e.g., new_category">
            </div>
            <div class="input-group">
                <label for="categoryNameInput">Display Name:</label>
                <input type="text" id="categoryNameInput" placeholder="e.g., My Custom Category">
            </div>
            <div class="input-group">
                <label for="categoryIconInput">Emoji Icon:</label>
                <input type="text" id="categoryIconInput" placeholder="e.g., ✨">
            </div>
            <div class="modal-buttons">
                <button class="modal-button confirm" id="saveCategoryBtn">Save Category</button>
                <button class="modal-button cancel" onclick="closeAddEditCategoryModal()">Cancel</button>
            </div>
        </div>
    </div>


    <div id="tooltipBox" class="tooltip-box"></div>

    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
    <script>
        // Global variables for modals to store context
        let currentEditingCriteriaId = null;
        let currentEditingCriteriaCategory = null;
        let currentEditingStrategyId = null;
        let currentEditingCategoryId = null; // New: For category editing

        // New: For Drag and Drop
        let categoryOrder = []; 
        let draggedCategoryId = null; 
        let placeholder = null; 

        // Built-in categories and their properties (name, icon, isDefault flag)
        let categories = {
            'levels': { name: 'Levels', icon: '📊', isDefault: true },
            'volume': { name: 'Volume Analysis', icon: '📈', isDefault: true },
            'timeframe': { name: 'Timeframe Alignment', icon: '⏱️', isDefault: true },
            'oscillators': { name: 'Oscillator Signals', icon: '📊', isDefault: true },
            'tape': { name: 'Tape Reading', icon: '📋', isDefault: true },
            'l2': { name: 'Level 2', icon: '🎚️', isDefault: true },
            'strategy-specific': { name: 'Strategy Specific', icon: '⭐', isDefault: true },
            'chart-patterns': { name: 'Chart Patterns', icon: '📈', isDefault: true }
        };
        // Custom categories will be loaded/saved into this `categories` object, marked `isDefault: false`.
        
        // Built-in strategies with default risk management details
        let strategies = {
            'reversal': { name: 'Reversal', color: '#e53e3e', icon: '🔄', defaultRisk: 1.0, defaultReward: 1.0, defaultStop: 'Price action failure at level', defaultTarget: 'Previous swing low/high' },
            'momentum': { name: 'Momentum', color: '#38a169', icon: '🚀', defaultRisk: 0.5, defaultReward: 1.5, defaultStop: 'Bar trail / VWAP break', defaultTarget: 'Gas out (L2/T&S slowdown)' },
            'both': { name: 'Both', color: 'linear-gradient(45deg, #e53e3e, #38a169)', icon: '⚖️', defaultRisk: 1.0, defaultReward: 1.0, defaultStop: 'Hybrid approach (consider tightest stop)', defaultTarget: 'Hybrid approach (consider nearest target)' },
            'scalping': { name: 'Scalping', color: '#9F7AEA', icon: '⚡', defaultRisk: 0.3, defaultReward: 0.6, defaultStop: 'Tick-based / Immediate invalidation', defaultTarget: 'Few ticks profit / L2 fill' },
            'swing': { name: 'Swing', color: '#3182CE', icon: '📈', defaultRisk: 1.5, defaultReward: 3.0, defaultStop: 'Key structural break / Daily close below', defaultTarget: 'Major resistance / Multi-day move' },
            'breakout': { name: 'Breakout', color: '#DD6B20', icon: '💥', defaultRisk: 0.7, defaultReward: 1.8, defaultStop: 'Retest failure / Volume exhaustion', defaultTarget: 'Measured move / Next major level' }
        };
        
        // Custom strategies will be loaded/saved here
        let customStrategies = {};
        // Custom criteria will be loaded/saved here
        let customCriteria = {}; 
        // New: Array to store IDs of default criteria that have been deleted by the user
        let deletedDefaultCriteria = [];
        
        // Variable to keep track of the currently active filter
        let currentFilter = 'all'; 

        // New: Store saved layouts
        let savedLayouts = {};

        // New: Default criteria data (immutable)
        const defaultCriteriaData = {
            'levels': [
                { id: 'sr-level', name: 'Price at major S/R, VAH/VAL, or IB range', strategies: ['both'], risk: 1, reward: 1, info: 'S/R (Support/Resistance) levels are price points where the price trend is expected to pause or reverse. VAH/VAL (Value Area High/Low) are key levels from volume profile. IB (Initial Balance) refers to the first hour\'s trading range.' },
                { id: 'vah-val', name: 'At VAH/VAL key level', strategies: ['reversal'], risk: 0.8, reward: 1.2, info: 'VAH (Value Area High) and VAL (Value Area Low) are derived from Volume Profile, representing the upper and lower boundaries of where the majority of trading volume occurred.' },
                { id: 'ib-range', name: 'Within IB Range boundary', strategies: ['both'], risk: 1, reward: 1, info: 'IB (Initial Balance) is the trading range established during the first hour of a trading session, often used to gauge initial market sentiment and potential range expansion.' }
            ],
            'volume': [
                { id: 'weak-volume', name: 'Volume weakening into level', strategies: ['reversal'], risk: 1.5, reward: 0.7, info: 'Weakening volume into a level suggests that the current price movement is losing conviction, often preceding a reversal.' },
                { id: 'volume-spike', name: 'Volume spike confirms push', strategies: ['momentum'], risk: 0.7, reward: 1.3, info: 'A sudden increase in volume (volume spike) often confirms the strength of a price move, indicating strong participation.' },
                { id: 'breakout-volume', name: 'Breakout above IBH/VAL/VAH with volume', strategies: ['momentum', 'breakout'], risk: 0.6, reward: 1.4, info: 'A breakout with significant volume indicates strong conviction behind the move, increasing the likelihood of continuation.' },
                { id: 'scalping-volume-confirm', name: 'High volume confirms scalping entry/exit', strategies: ['scalping'], risk: 0.9, reward: 1.1, info: 'For scalping, high volume at entry/exit points confirms liquidity and order flow, crucial for quick trades.' },
                { id: 'swing-volume-confirmation', name: 'Volume confirmation on swing lows/highs', strategies: ['swing'], risk: 1.0, reward: 1.5, info: 'Volume confirmation at swing lows/highs indicates strong support or resistance, validating potential swing trade entries.' }
            ],
            'timeframe': [
                { id: 'trend-align', name: 'Trend aligns (VWAP, EMA, 200EMA support)', strategies: ['momentum', 'swing'], risk: 0.7, reward: 1.3, info: 'VWAP (Volume Weighted Average Price) and EMAs (Exponential Moving Averages) are indicators used to confirm trend direction and dynamic support/resistance.' },
                { id: 'micro-pullback', name: 'Micro pullback to VWAP/EMA/VAL', strategies: ['momentum', 'scalping'], risk: 0.8, reward: 1.2, info: 'A micro pullback is a small, temporary reversal within a strong trend, offering an opportunity to join the trend at a better price.' },
                { id: 'stall-curl', name: '15s shows stall/curl or failed push', strategies: ['reversal'], risk: 1.2, reward: 0.8, info: 'A stall or curl on a lower timeframe (e.g., 15s) indicates a loss of momentum in the current move, often preceding a reversal.' },
                { id: 'swing-daily-chart', name: 'Daily chart confirms broader trend for swing', strategies: ['swing'], risk: 0.9, reward: 1.5, info: 'For swing trades, confirming the broader trend on a daily chart helps align with larger market movements, improving trade probability.' }
            ],
            'oscillators': [
                { id: 'oscillator-divergence', name: 'Oscillator divergence or flattening', strategies: ['reversal', 'swing'], risk: 1.1, reward: 0.9, info: 'Divergence occurs when price makes a new high/low, but an oscillator (like MACD or RSI) does not, often signaling a potential reversal. ' },
                { id: 'oscillator-trend', name: 'Oscillator confirms trend direction', strategies: ['momentum', 'breakout'], risk: 0.8, reward: 1.2, info: 'An oscillator confirming the trend (e.g., staying above 0 for MACD in an uptrend) indicates sustained momentum.' },
                { id: 'rsi-overbought-oversold', name: 'RSI Overbought/Oversold signal', strategies: ['reversal'], risk: 1.0, reward: 1.0, info: 'RSI (Relative Strength Index) measures the speed and change of price movements. Overbought (above 70) or oversold (below 30) signals can indicate potential reversals.' }
            ],
            'tape': [
                { id: 'absorption', name: 'Large passive order + absorption', strategies: ['reversal'], risk: 1.2, reward: 0.8, info: 'Absorption occurs when large orders are being filled by aggressive buyers/sellers without significant price movement, indicating strong supply/demand at a level.' },
                { id: 'aggressive-orders', name: 'Aggressive orders pushing', strategies: ['momentum', 'scalping', 'breakout'], risk: 0.7, reward: 1.3, info: 'Aggressive orders (market orders) indicate strong conviction and can drive price quickly in a particular direction. ' },
                { id: 'slowed-prints', name: 'T&S: Slowed prints, lack of aggression', strategies: ['reversal'], risk: 1.3, reward: 0.7, info: 'T&S (Time & Sales) shows individual trades. Slowed prints and lack of aggression indicate waning momentum, often preceding a reversal.' },
                { id: 'speed-increasing', name: 'T&S: Speed + size increasing', strategies: ['momentum', 'scalping', 'breakout'], risk: 0.6, reward: 1.4, info: 'Increasing speed and size of prints on Time & Sales indicates strong order flow and momentum.' }
            ],
            'l2': [
                { id: 'thin-liquidity', name: 'L2: Thin liquidity in breakout path', strategies: ['momentum', 'breakout'], risk: 0.9, reward: 1.1, info: 'L2 (Level 2) shows the order book depth. Thin liquidity in the direction of a breakout means less resistance for price to move.' },
                { id: 'no-gaps', name: 'L2: No major liquidity gaps behind you', strategies: ['reversal'], risk: 0.8, reward: 1.2, info: 'Liquidity gaps on Level 2 mean there are no large orders to absorb selling/buying pressure, which can lead to rapid price movement. ' },
                { id: 'scalping-l2-depth', name: 'L2: Sufficient depth for scalping entry/exit', strategies: ['scalping'], risk: 0.9, reward: 1.1, info: 'For scalping, sufficient depth on Level 2 ensures there are enough orders to fill your entry and exit quickly without significant slippage.' }
            ],
            'strategy-specific': [
                { id: 'scalping-tight-stop', name: 'Scalping: Tight stop-loss and quick profit target', strategies: ['scalping'], risk: 0.5, reward: 0.5, info: 'Scalping involves taking very small profits with tight stop-losses, requiring precise entries and exits.' },
                { id: 'swing-overnight-risk', name: 'Swing: Comfortable with overnight risk', strategies: ['swing'], risk: 1.2, reward: 1.8, info: 'Swing trading involves holding positions for several days or weeks, exposing trades to overnight market movements and news.' },
                { id: 'breakout-retest-entry', name: 'Breakout: Waiting for retest of broken level for entry', strategies: ['breakout'], risk: 0.7, reward: 1.3, info: 'After a breakout, price often retests the broken level before continuing in the breakout direction, offering a lower-risk entry. ' }
            ],
            'chart-patterns': [
                { id: 'double-top-bottom', name: 'Double Top/Bottom identified', strategies: ['reversal', 'swing'], risk: 1.0, reward: 1.5, info: 'Double Top/Bottom are reversal patterns indicating a potential change in trend after two failed attempts to break a resistance/support level. ' },
                { id: 'head-shoulders', name: 'Head & Shoulders (or inverse) pattern', strategies: ['reversal', 'swing'], risk: 1.1, reward: 1.6, info: 'Head & Shoulders (or inverse) is a classic reversal pattern, characterized by three peaks/troughs with the middle one being the highest/lowest.' },
                { id: 'flags-pennants', name: 'Flags/Pennants confirming continuation', strategies: ['momentum', 'breakout'], risk: 0.8, reward: 1.2, info: 'Flags and Pennants are continuation patterns that form after a sharp price move, indicating a temporary pause before the trend resumes.' }
            ]
        };


        /**
         * Shows a custom modal dialog.
         * @param {string} title The title of the modal.
         * @param {string} message The message content of the modal.
         * @param {Function} onConfirm Callback function for the confirm action.
         * @param {Function} onCancel Callback function for the cancel action.
         * @param {boolean} showCancelButton Whether to show the cancel button.
         * @param {boolean} showOkButton Whether to show a single OK button (for alerts).
         * @param {object} inputOptions Options for an input field: { show: boolean, label: string, placeholder: string, defaultValue: string }
         */
        function showModal(title, message, onConfirm, onCancel, showCancelButton = true, showOkButton = false, inputOptions = {}) {
            const modal = document.getElementById('customModal');
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;

            const confirmBtn = document.getElementById('modalConfirmBtn');
            const cancelBtn = document.getElementById('modalCancelBtn');
            const okBtn = document.getElementById('modalOkBtn');
            const inputContainer = document.getElementById('modalInputContainer');
            const modalInput = document.getElementById('modalInput');
            const modalInputLabel = document.getElementById('modalInputLabel');

            // Reset event listeners to prevent multiple calls
            confirmBtn.onclick = null;
            cancelBtn.onclick = null;
            okBtn.onclick = null;

            // Handle input field
            if (inputOptions.show) {
                inputContainer.style.display = 'block';
                modalInputLabel.textContent = inputOptions.label || '';
                modalInput.placeholder = inputOptions.placeholder || '';
                modalInput.value = inputOptions.defaultValue || '';
                modalInput.focus(); // Focus the input field
                // Allow pressing Enter in the input to trigger confirm
                modalInput.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent form submission
                        confirmBtn.click();
                    }
                };
            } else {
                inputContainer.style.display = 'none';
                modalInput.value = '';
                modalInput.onkeydown = null;
            }

            if (showOkButton) {
                confirmBtn.style.display = 'none';
                cancelBtn.style.display = 'none';
                okBtn.style.display = 'inline-block';
                okBtn.onclick = () => {
                    modal.classList.add('hidden');
                    if (onConfirm) onConfirm();
                };
            } else {
                confirmBtn.style.display = 'inline-block';
                cancelBtn.style.display = showCancelButton ? 'inline-block' : 'none';
                okBtn.style.display = 'none';

                confirmBtn.onclick = () => {
                    modal.classList.add('hidden');
                    // Pass the input value to the onConfirm callback if an input was shown
                    if (onConfirm) {
                        if (inputOptions.show) {
                            onConfirm(modalInput.value);
                        } else {
                            onConfirm();
                        }
                    }
                };
                cancelBtn.onclick = () => {
                    modal.classList.add('hidden');
                    if (onCancel) onCancel();
                };
            }
            modal.classList.remove('hidden');
        }

        /**
         * Saves the current state of the checklist to localStorage.
         * This includes checked inputs, custom strategies, custom criteria, notes, P&L inputs, and category order.
         */
        function saveState() {
            const state = {
                checkedInputs: [],
                customStrategies: customStrategies,
                customCriteria: customCriteria,
                deletedDefaultCriteria: deletedDefaultCriteria, 
                notes: document.getElementById('trade-notes').value,
                darkMode: document.body.classList.contains('dark-mode'),
                tradeSize: document.getElementById('tradeSize').value,
                tickValue: document.getElementById('tickValue').value,
                futuresTickSize: document.getElementById('futuresTickSize').value, 
                entryPrice: document.getElementById('entryPrice').value,
                savedLayouts: savedLayouts, 
                categories: categories, 
                categoryOrder: categoryOrder // Save the category order
            };

            document.querySelectorAll('.input').forEach(input => {
                if (input.checked) {
                    state.checkedInputs.push(input.id);
                }
            });

            localStorage.setItem('futuresChecklistState', JSON.stringify(state));
            console.log('Checklist state saved to localStorage:', state); 
        }

        /**
         * Loads the saved state from localStorage and restores the checklist.
         */
        function loadState() {
            const savedState = localStorage.getItem('futuresChecklistState');
            if (savedState) {
                const state = JSON.parse(savedState);
                console.log('Checklist state loaded from localStorage:', state); 

                savedLayouts = state.savedLayouts || {};
                deletedDefaultCriteria = state.deletedDefaultCriteria || [];
                
                const defaultCats = {
                    'levels': { name: 'Levels', icon: '📊', isDefault: true },
                    'volume': { name: 'Volume Analysis', icon: '📈', isDefault: true },
                    'timeframe': { name: 'Timeframe Alignment', icon: '⏱️', isDefault: true },
                    'oscillators': { name: 'Oscillator Signals', icon: '📊', isDefault: true },
                    'tape': { name: 'Tape Reading', icon: '📋', isDefault: true },
                    'l2': { name: 'Level 2', icon: '🎚️', isDefault: true },
                    'strategy-specific': { name: 'Strategy Specific', icon: '⭐', isDefault: true },
                    'chart-patterns': { name: 'Chart Patterns', icon: '📈', isDefault: true }
                };
                categories = { ...defaultCats, ...(state.categories || {}) };

                // Load category order
                // Ensure all current categories are in the order, adding new ones to the end if necessary
                const loadedOrder = state.categoryOrder || Object.keys(categories);
                const currentCategoryIds = Object.keys(categories);
                categoryOrder = loadedOrder.filter(id => currentCategoryIds.includes(id)); // Keep only existing
                currentCategoryIds.forEach(id => { // Add any new categories not in the loaded order
                    if (!categoryOrder.includes(id)) {
                        categoryOrder.push(id);
                    }
                });


                applyLoadedState(state, false); 
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('darkModeToggle').textContent = '☀️ Light Mode';
                // Initialize categoryOrder with default keys if no saved state
                categoryOrder = Object.keys(categories); 
                loadDefaultLayout(true); 
            }
            console.log('PNL inputs after loadState:', {
                tradeSize: document.getElementById('tradeSize').value,
                tickValue: document.getElementById('tickValue').value,
                futuresTickSize: document.getElementById('futuresTickSize').value, 
                entryPrice: document.getElementById('entryPrice').value,
            });
            updateChecklistState(); 
            applyStrategyFilter(currentFilter);
        }


        /**
         * Applies a loaded state object to the checklist.
         * Used by both loadState and importSettings.
         * @param {object} state The state object to apply.
         * @param {boolean} clearExistingData If true, clears all custom strategies and criteria before applying.
         */
        function applyLoadedState(state, clearExistingData) {
            if (clearExistingData) {
                customStrategies = {};
                customCriteria = {};
                deletedDefaultCriteria = state.deletedDefaultCriteria || []; 
                
                const defaultCats = {
                    'levels': { name: 'Levels', icon: '📊', isDefault: true },
                    'volume': { name: 'Volume Analysis', icon: '📈', isDefault: true },
                    'timeframe': { name: 'Timeframe Alignment', icon: '⏱️', isDefault: true },
                    'oscillators': { name: 'Oscillator Signals', icon: '📊', isDefault: true },
                    'tape': { name: 'Tape Reading', icon: '📋', isDefault: true },
                    'l2': { name: 'Level 2', icon: '🎚️', isDefault: true },
                    'strategy-specific': { name: 'Strategy Specific', icon: '⭐', isDefault: true },
                    'chart-patterns': { name: 'Chart Patterns', icon: '📈', isDefault: true }
                };
                categories = { ...defaultCats }; 
                categoryOrder = state.categoryOrder || Object.keys(categories); // Reset or load order

                document.querySelectorAll('.category').forEach(el => {
                    if (!defaultCats.hasOwnProperty(el.getAttribute('data-group'))) {
                        el.remove(); 
                    }
                });
                document.querySelectorAll('.checklist-item').forEach(el => el.remove()); 
                document.querySelectorAll('.input').forEach(input => {
                    input.checked = false;
                });
            }

            if (state.categories) {
                for (const id in state.categories) {
                    if (!categories[id]) { 
                        categories[id] = state.categories[id];
                    } else if (!categories[id].isDefault) { 
                        categories[id] = { ...categories[id], ...state.categories[id] };
                    }
                }
            }
            
            // Update categoryOrder from the loaded state or ensure it's initialized
            if (state.categoryOrder) {
                categoryOrder = state.categoryOrder;
            } else if (clearExistingData || categoryOrder.length === 0) { // If clearing data or order is empty
                categoryOrder = Object.keys(categories);
            }
            // Ensure all current categories are in the order, adding new ones to the end if necessary
            const currentCategoryIds = Object.keys(categories);
            categoryOrder = categoryOrder.filter(id => currentCategoryIds.includes(id)); // Keep only existing
            currentCategoryIds.forEach(id => { // Add any new categories not in the loaded order
                if (!categoryOrder.includes(id)) {
                    categoryOrder.push(id);
                }
            });


            for (const id in state.customStrategies) {
                customStrategies[id] = state.customStrategies[id];
                addStrategyCSS(id, customStrategies[id].color);
            }

            for (const category in state.customCriteria) {
                if (!customCriteria[category]) {
                    customCriteria[category] = [];
                }
                state.customCriteria[category].forEach(item => {
                    if (!document.getElementById(item.id)) {
                        customCriteria[category].push(item);
                        addCategoryDivToDOM(category, categories[category]?.name, categories[category]?.icon, categories[category]?.isDefault); 
                        createCustomCriteriaElement(category, item.id, item.name, item.strategies, item.risk || 1.0, item.reward || 1.0, item.info || '');
                    }
                });
            }

            createFilterButtons();
            recreateAllCriteriaElements(); // This will respect the categoryOrder

            document.querySelectorAll('.input').forEach(input => {
                input.checked = false; 
            });
            state.checkedInputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.checked = true;
                }
            });

            document.getElementById('trade-notes').value = state.notes || '';
            document.getElementById('tradeSize').value = state.tradeSize !== undefined ? state.tradeSize : '1';
            document.getElementById('tickValue').value = state.tickValue !== undefined ? state.tickValue : '5.00';
            document.getElementById('futuresTickSize').value = state.futuresTickSize !== undefined ? state.futuresTickSize : '0.25'; 
            document.getElementById('entryPrice').value = state.entryPrice !== undefined ? state.entryPrice : '0.00';

            if (state.darkMode) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').textContent = '🌙 Dark Mode';
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('darkModeToggle').textContent = '☀️ Light Mode';
            }
            
            document.querySelectorAll(".input").forEach(input => {
                input.removeEventListener("change", updateChecklistState); 
                input.removeEventListener("change", saveState);
                input.addEventListener("change", updateChecklistState);
                input.addEventListener("change", saveState);
            });

            document.querySelectorAll('label[data-info]').forEach(label => {
                label.removeEventListener('mouseover', showTooltip);
                label.removeEventListener('mouseout', hideTooltip);
                label.addEventListener('mouseover', showTooltip);
                label.addEventListener('mouseout', hideTooltip);
            });

            const potentialLossElement = document.getElementById('potentialLoss');
            const potentialProfitElement = document.getElementById('potentialProfit');
            potentialLossElement.removeEventListener('mouseover', showTooltip);
            potentialLossElement.removeEventListener('mouseout', hideTooltip);
            potentialProfitElement.removeEventListener('mouseover', showTooltip);
            potentialProfitElement.removeEventListener('mouseout', hideTooltip);
            potentialLossElement.addEventListener('mouseover', showTooltip);
            potentialLossElement.addEventListener('mouseout', hideTooltip);
            potentialProfitElement.addEventListener('mouseover', showTooltip);
            potentialProfitElement.addEventListener('mouseout', hideTooltip);

            const calculatedRiskElement = document.getElementById('calculated-risk');
            const calculatedRewardElement = document.getElementById('calculated-reward');
            calculatedRiskElement.removeEventListener('mouseover', showTooltip);
            calculatedRiskElement.removeEventListener('mouseout', hideTooltip);
            calculatedRewardElement.removeEventListener('mouseover', showTooltip);
            calculatedRewardElement.removeEventListener('mouseout', hideTooltip);
            calculatedRiskElement.addEventListener('mouseover', showTooltip);
            calculatedRiskElement.addEventListener('mouseout', hideTooltip);
            calculatedRewardElement.addEventListener('mouseover', showTooltip);
            calculatedRewardElement.addEventListener('mouseout', hideTooltip);

            updateChecklistState(); 
            applyStrategyFilter(currentFilter); 
        }

        /**
         * Resets only the checked criteria.
         * Does NOT reset notes or P&L inputs.
         */
        function resetCheckedCriteria() {
            showModal(
                "Confirm Reset Checks",
                "Are you sure you want to uncheck all criteria items? Your notes and P&L inputs will remain unchanged.",
                () => { // onConfirm
                    document.querySelectorAll('.input').forEach(input => {
                        input.checked = false;
                    });
                    saveState(); // Save the cleared checks
                    updateChecklistState(); // Update the result display
                    showModal("Checks Reset", "All criteria have been unchecked.", null, null, false, true);
                },
                () => { /* onCancel - do nothing */ },
                true // showCancelButton
            );
        }


        /**
         * Opens the modal to manage strategies.
         */
        function openManageStrategiesModal() {
            const strategyListContainer = document.getElementById('strategyListContainer');
            strategyListContainer.innerHTML = ''; 

            const allStrategies = { ...strategies, ...customStrategies };

            for (const id in allStrategies) {
                const strategy = allStrategies[id];
                const isCustom = customStrategies.hasOwnProperty(id);

                const strategyDiv = document.createElement('div');
                strategyDiv.className = 'checklist-item'; 
                strategyDiv.innerHTML = `
                    <span class="strategy-icon">${strategy.icon}</span>
                    <label style="flex-grow: 1;">${strategy.name} (${id}) ${isCustom ? '(Custom)' : '(Built-in)'}</label>
                    <div class="strategy-badges"></div> ${isCustom ? `<button class="edit-criteria-btn" onclick="openEditStrategyModal('${id}')" title="Edit this strategy">✏️</button>` : ''}
                    ${isCustom ? `<button class="delete-criteria-btn" onclick="confirmDeleteStrategy('${id}')" title="Delete this strategy">x</button>` : ''}
                `;
                strategyListContainer.appendChild(strategyDiv);
            }
            document.getElementById('manageStrategiesModal').classList.remove('hidden');
        }

        function closeManageStrategiesModal() {
            document.getElementById('manageStrategiesModal').classList.add('hidden');
        }

        /**
         * Opens the modal to add a new strategy.
         */
        function openAddStrategyModal() {
            document.getElementById('addEditStrategyTitle').textContent = 'Add New Strategy';
            document.getElementById('strategyIdInput').value = '';
            document.getElementById('strategyIdInput').readOnly = false; 
            document.getElementById('strategyNameInput').value = '';
            document.getElementById('strategyColorInput').value = '#3182ce'; 
            document.getElementById('strategyIconInput').value = '📊'; 
            document.getElementById('strategyDefaultRiskInput').value = '1.0';
            document.getElementById('strategyDefaultRewardInput').value = '1.0';
            document.getElementById('strategyDefaultStopInput').value = '';
            document.getElementById('strategyDefaultTargetInput').value = '';
            
            document.getElementById('saveStrategyBtn').onclick = saveNewStrategy;
            document.getElementById('addEditStrategyModal').classList.remove('hidden');
        }

        /**
         * Opens the modal to edit an existing strategy.
         * @param {string} strategyId The ID of the strategy to edit.
         */
        function openEditStrategyModal(strategyId) {
            const strategy = customStrategies[strategyId];
            if (!strategy) {
                showModal("Error", "Strategy not found!", null, null, false, true);
                return;
            }
            currentEditingStrategyId = strategyId; 

            document.getElementById('addEditStrategyTitle').textContent = `Edit Strategy: ${strategy.name}`;
            document.getElementById('strategyIdInput').value = strategyId;
            document.getElementById('strategyIdInput').readOnly = true; 
            document.getElementById('strategyNameInput').value = strategy.name;
            document.getElementById('strategyColorInput').value = strategy.color.startsWith('linear-gradient') ? '#3182ce' : strategy.color; 
            document.getElementById('strategyIconInput').value = strategy.icon;
            document.getElementById('strategyDefaultRiskInput').value = strategy.defaultRisk;
            document.getElementById('strategyDefaultRewardInput').value = strategy.defaultReward;
            document.getElementById('strategyDefaultStopInput').value = strategy.defaultStop;
            document.getElementById('strategyDefaultTargetInput').value = strategy.defaultTarget;

            document.getElementById('saveStrategyBtn').onclick = saveEditedStrategy;
            document.getElementById('addEditStrategyModal').classList.remove('hidden');
        }

        function closeAddEditStrategyModal() {
            document.getElementById('addEditStrategyModal').classList.add('hidden');
            currentEditingStrategyId = null;
            openManageStrategiesModal(); 
        }

        /**
         * Saves a new strategy from the modal inputs.
         */
        function saveNewStrategy() {
            const id = document.getElementById('strategyIdInput').value.trim().toLowerCase().replace(/\s+/g, '');
            const name = document.getElementById('strategyNameInput').value.trim();
            const color = document.getElementById('strategyColorInput').value;
            const icon = document.getElementById('strategyIconInput').value.trim();
            const defaultRisk = parseFloat(document.getElementById('strategyDefaultRiskInput').value);
            const defaultReward = parseFloat(document.getElementById('strategyDefaultRewardInput').value);
            const defaultStop = document.getElementById('strategyDefaultStopInput').value.trim();
            const defaultTarget = document.getElementById('strategyDefaultTargetInput').value.trim();

            if (!id || !name) {
                showModal("Validation Error", "Strategy ID and Display Name are required.", null, null, false, true);
                return;
            }
            if (strategies[id] || customStrategies[id]) {
                showModal("Validation Error", "Strategy ID already exists.", null, null, false, true);
                return;
            }
            if (isNaN(defaultRisk) || isNaN(defaultReward)) {
                 showModal("Validation Error", "Risk and Reward values must be numbers.", null, null, false, true);
                 return;
            }

            customStrategies[id] = { name, color, icon, defaultRisk, defaultReward, defaultStop, defaultTarget };
            addStrategyCSS(id, color);
            createFilterButtons();
            saveState();
            closeAddEditStrategyModal();
            showModal("Success", `Strategy "${name}" added!`, null, null, false, true);
        }

        /**
         * Saves an edited strategy from the modal inputs.
         */
        function saveEditedStrategy() {
            const id = currentEditingStrategyId;
            const name = document.getElementById('strategyNameInput').value.trim();
            const color = document.getElementById('strategyColorInput').value;
            const icon = document.getElementById('strategyIconInput').value.trim();
            const defaultRisk = parseFloat(document.getElementById('strategyDefaultRiskInput').value);
            const defaultReward = parseFloat(document.getElementById('strategyDefaultRewardInput').value);
            const defaultStop = document.getElementById('strategyDefaultStopInput').value.trim();
            const defaultTarget = document.getElementById('strategyDefaultTargetInput').value.trim();

            if (!name) {
                showModal("Validation Error", "Display Name is required.", null, null, false, true);
                return;
            }
            if (isNaN(defaultRisk) || isNaN(defaultReward)) {
                 showModal("Validation Error", "Risk and Reward values must be numbers.", null, null, false, true);
                 return;
            }

            customStrategies[id] = { name, color, icon, defaultRisk, defaultReward, defaultStop, defaultTarget };
            addStrategyCSS(id, color);
            createFilterButtons();
            recreateAllCriteriaElements();
            saveState();
            closeAddEditStrategyModal();
            showModal("Success", `Strategy "${name}" updated!`, null, null, false, true);
        }

        /**
         * Confirms deletion of a custom strategy.
         * @param {string} strategyId The ID of the strategy to delete.
         */
        function confirmDeleteStrategy(strategyId) {
            const strategyName = customStrategies[strategyId].name;
            showModal(
                "Confirm Deletion",
                `Are you sure you want to delete the custom strategy "${strategyName}"? This cannot be undone. All criteria using this strategy will be updated.`,
                () => { // onConfirm
                    delete customStrategies[strategyId];
                    updateCriteriaAfterStrategyDelete(strategyId); 
                    const styleTag = document.getElementById(`style-${strategyId}`);
                    if (styleTag) {
                        styleTag.remove();
                    }
                    createFilterButtons();
                    saveState();
                    updateChecklistState();
                    closeManageStrategiesModal(); 
                    showModal("Success", `Strategy "${strategyName}" deleted successfully!`, null, null, false, true);
                },
                () => { /* onCancel - do nothing */ },
                true
            );
        }

        /**
         * Opens the modal to add a new criteria.
         * @param {string} category The category to pre-select.
         */
        function openAddCriteriaModal(category = '') {
            document.getElementById('addEditCriteriaTitle').textContent = 'Add New Criteria';
            currentEditingCriteriaId = null; 

            document.getElementById('criteriaNameInput').value = '';
            document.getElementById('criteriaRiskInput').value = '1.0';
            document.getElementById('criteriaRewardInput').value = '1.0';
            document.getElementById('criteriaInfoInput').value = '';

            populateCategorySelect(category);
            populateAvailableStrategiesHint();
            document.getElementById('criteriaStrategiesInput').value = ''; 

            document.getElementById('saveCriteriaBtn').onclick = saveNewCriteria;
            document.getElementById('addEditCriteriaModal').classList.remove('hidden');
        }

        /**
         * Opens the modal to edit an existing criteria.
         * @param {string} itemId The ID of the criteria to edit.
         * @param {string} category The category the item belongs to.
         */
        function openEditCriteriaModal(itemId, category) {
            const inputElement = document.getElementById(itemId);
            if (!inputElement) {
                showModal("Error", "Criteria not found!", null, null, false, true);
                return;
            }

            currentEditingCriteriaId = itemId;
            currentEditingCriteriaCategory = category;

            const currentLabel = inputElement.nextElementSibling;
            const currentName = currentLabel.textContent;
            const currentStrategies = inputElement.getAttribute('data-strategies') || '';
            const currentRisk = parseFloat(inputElement.getAttribute('data-risk')) || 1.0;
            const currentReward = parseFloat(inputElement.getAttribute('data-reward')) || 1.0;
            const currentInfo = currentLabel.getAttribute('data-info') || '';

            document.getElementById('addEditCriteriaTitle').textContent = `Edit Criteria: ${currentName}`;
            document.getElementById('criteriaNameInput').value = currentName;
            document.getElementById('criteriaRiskInput').value = currentRisk;
            document.getElementById('criteriaRewardInput').value = currentReward;
            document.getElementById('criteriaInfoInput').value = currentInfo;
            document.getElementById('criteriaStrategiesInput').value = currentStrategies;

            populateCategorySelect(category);
            populateAvailableStrategiesHint();

            document.getElementById('saveCriteriaBtn').onclick = saveEditedCriteria;
            document.getElementById('addEditCriteriaModal').classList.remove('hidden');
        }

        function closeAddEditCriteriaModal() {
            document.getElementById('addEditCriteriaModal').classList.add('hidden');
            currentEditingCriteriaId = null;
            currentEditingCriteriaCategory = null;
        }

        /**
         * Populates the category select dropdown in the criteria modal.
         * @param {string} selectedCategory The category to pre-select.
         */
        function populateCategorySelect(selectedCategory = '') {
            const select = document.getElementById('criteriaCategorySelect');
            select.innerHTML = ''; 

            for (const id in categories) {
                const category = categories[id];
                const option = document.createElement('option');
                option.value = id;
                option.textContent = `${category.icon} ${category.name}`;
                select.appendChild(option);
            }

            if (selectedCategory) {
                select.value = selectedCategory;
            } else if (select.options.length > 0) {
                select.value = select.options[0].value; 
            }
        }

        /**
         * Populates the hint for available strategies in the criteria modal.
         */
        function populateAvailableStrategiesHint() {
            const hintSpan = document.getElementById('availableStrategiesHint');
            const allStrategyNames = Object.values(strategies).map(s => s.name)
                                    .concat(Object.values(customStrategies).map(s => s.name));
            hintSpan.textContent = allStrategyNames.join(', ');
        }

        /**
         * Saves a new criteria from the modal inputs.
         */
        function saveNewCriteria() {
            const name = document.getElementById('criteriaNameInput').value.trim();
            const category = document.getElementById('criteriaCategorySelect').value;
            const strategiesInput = document.getElementById('criteriaStrategiesInput').value.trim();
            const risk = parseFloat(document.getElementById('criteriaRiskInput').value);
            const reward = parseFloat(document.getElementById('criteriaRewardInput').value);
            const info = document.getElementById('criteriaInfoInput').value.trim();

            if (!name || !category || !strategiesInput) {
                showModal("Validation Error", "Criteria Name, Category, and Strategies are required.", null, null, false, true);
                return;
            }
            if (isNaN(risk) || isNaN(reward)) {
                 showModal("Validation Error", "Risk and Reward values must be numbers.", null, null, false, true);
                 return;
            }

            const inputStrategies = strategiesInput.split(',').map(s => s.trim().toLowerCase());
            let validStrategies = [];
            for (let strategyInput of inputStrategies) {
                if (strategyInput === '') continue;
                if (strategies[strategyInput] || customStrategies[strategyInput]) {
                    validStrategies.push(strategyInput);
                } else {
                    showModal(
                        "New Strategy Detected",
                        `The strategy "${strategyInput}" is not recognized. Would you like to add it as a new custom strategy?`,
                        () => {
                            closeAddEditCriteriaModal(); 
                            openAddStrategyModal();
                            document.getElementById('strategyIdInput').value = strategyInput; 
                            document.getElementById('strategyNameInput').value = strategyInput.charAt(0).toUpperCase() + strategyInput.slice(1); 
                            document.getElementById('saveStrategyBtn').onclick = () => {
                                saveNewStrategyAndContinueCriteria(strategyInput, name, category, strategiesInput, risk, reward, info);
                            };
                        },
                        () => {
                            showModal("Validation Error", `Criteria not saved. Unrecognized strategy "${strategyInput}" was not added.`, null, null, false, true);
                        },
                        true
                    );
                    return; 
                }
            }

            if (validStrategies.length === 0) {
                showModal("Validation Error", "No valid strategies provided for this criteria.", null, null, false, true);
                return;
            }

            const itemId = `custom-${Date.now()}`;
            if (!customCriteria[category]) {
                customCriteria[category] = [];
            }
            customCriteria[category].push({ id: itemId, name, strategies: validStrategies, risk, reward, info });
            createCustomCriteriaElement(category, itemId, name, validStrategies, risk, reward, info);
            saveState();
            updateChecklistState();
            closeAddEditCriteriaModal();
            showModal("Success", `Criteria "${name}" added!`, null, null, false, true);
        }

        /**
         * Helper to save new strategy and then continue saving criteria.
         * Called from saveNewCriteria when a new strategy is detected and confirmed.
         */
        function saveNewStrategyAndContinueCriteria(newStrategyId, criteriaName, criteriaCategory, criteriaStrategiesInput, criteriaRisk, criteriaReward, criteriaInfo) {
            const id = document.getElementById('strategyIdInput').value.trim().toLowerCase().replace(/\s+/g, '');
            const name = document.getElementById('strategyNameInput').value.trim();
            const color = document.getElementById('strategyColorInput').value;
            const icon = document.getElementById('strategyIconInput').value.trim();
            const defaultRisk = parseFloat(document.getElementById('strategyDefaultRiskInput').value);
            const defaultReward = parseFloat(document.getElementById('strategyDefaultRewardInput').value);
            const defaultStop = document.getElementById('strategyDefaultStopInput').value.trim();
            const defaultTarget = document.getElementById('strategyDefaultTargetInput').value.trim();

            if (!id || !name || isNaN(defaultRisk) || isNaN(defaultReward)) {
                showModal("Validation Error", "Failed to save new strategy. Please fill all required fields.", null, null, false, true);
                return;
            }
            customStrategies[id] = { name, color, icon, defaultRisk, defaultReward, defaultStop, defaultTarget };
            addStrategyCSS(id, color);
            createFilterButtons();
            saveState(); 

            const inputStrategies = criteriaStrategiesInput.split(',').map(s => s.trim().toLowerCase());
            let validStrategies = [];
            for (let strategyInput of inputStrategies) {
                 if (strategies[strategyInput] || customStrategies[strategyInput]) {
                    validStrategies.push(strategyInput);
                }
            }

            const itemId = `custom-${Date.now()}`;
            if (!customCriteria[criteriaCategory]) {
                customCriteria[criteriaCategory] = [];
            }
            customCriteria[criteriaCategory].push({ id: itemId, name: criteriaName, strategies: validStrategies, risk: criteriaRisk, reward: criteriaReward, info: criteriaInfo });
            createCustomCriteriaElement(criteriaCategory, itemId, criteriaName, validStrategies, criteriaRisk, criteriaReward, criteriaInfo);
            saveState();
            updateChecklistState();
            closeAddEditStrategyModal(); 
            showModal("Success", `Strategy "${name}" added and Criteria "${criteriaName}" saved!`, null, null, false, true);
        }


        /**
         * Saves an edited criteria from the modal inputs.
         */
        function saveEditedCriteria() {
            const itemId = currentEditingCriteriaId;
            const category = currentEditingCriteriaCategory;

            const name = document.getElementById('criteriaNameInput').value.trim();
            const newCategory = document.getElementById('criteriaCategorySelect').value;
            const strategiesInput = document.getElementById('criteriaStrategiesInput').value.trim();
            const risk = parseFloat(document.getElementById('criteriaRiskInput').value);
            const reward = parseFloat(document.getElementById('criteriaRewardInput').value);
            const info = document.getElementById('criteriaInfoInput').value.trim();

            if (!name || !newCategory || !strategiesInput) {
                showModal("Validation Error", "Criteria Name, Category, and Strategies are required.", null, null, false, true);
                return;
            }
            if (isNaN(risk) || isNaN(reward)) {
                 showModal("Validation Error", "Risk and Reward values must be numbers.", null, null, false, true);
                 return;
            }

            const inputStrategies = strategiesInput.split(',').map(s => s.trim().toLowerCase());
            let validStrategies = [];
            for (let strategyInput of inputStrategies) {
                if (strategyInput === '') continue;
                if (strategies[strategyInput] || customStrategies[strategyInput]) {
                    validStrategies.push(strategyInput);
                } else {
                    showModal(
                        "New Strategy Detected",
                        `The strategy "${strategyInput}" is not recognized. Please add it as a new custom strategy first, or correct the spelling.`,
                        null, null, false, true
                    );
                    return;
                }
            }

            if (validStrategies.length === 0) {
                showModal("Validation Error", "No valid strategies provided for this criteria.", null, null, false, true);
                return;
            }

            const inputElement = document.getElementById(itemId);
            const labelElement = inputElement.nextElementSibling;
            const badgesContainer = inputElement.parentElement.querySelector('.strategy-badges');

            labelElement.textContent = name;
            inputElement.setAttribute('data-strategies', validStrategies.join(','));
            inputElement.setAttribute('data-risk', risk);
            inputElement.setAttribute('data-reward', reward);
            if (info) {
                labelElement.setAttribute('data-info', info);
                labelElement.removeEventListener('mouseover', showTooltip); 
                labelElement.removeEventListener('mouseout', hideTooltip);
                labelElement.addEventListener('mouseover', showTooltip);
                labelElement.addEventListener('mouseout', hideTooltip);
            } else {
                labelElement.removeAttribute('data-info');
                labelElement.removeEventListener('mouseover', showTooltip);
                labelElement.removeEventListener('mouseout', hideTooltip);
            }
            updateBadgeDisplay(badgesContainer, validStrategies);

            if (category !== newCategory) {
                if (customCriteria[category]) {
                    customCriteria[category] = customCriteria[category].filter(item => item.id !== itemId);
                    if (customCriteria[category].length === 0 && !categories[category].isDefault) {
                        delete customCriteria[category];
                        const oldCategoryDiv = document.querySelector(`.category[data-group="${category}"]`);
                        if (oldCategoryDiv) oldCategoryDiv.remove();
                    }
                }
                if (!customCriteria[newCategory]) {
                    customCriteria[newCategory] = [];
                }
                customCriteria[newCategory].push({ id: itemId, name, strategies: validStrategies, risk, reward, info });
                inputElement.parentElement.remove(); 
                createCustomCriteriaElement(newCategory, itemId, name, validStrategies, risk, reward, info);
            } else {
                // Check if the criteria is default or custom to decide where to update
                const isDefaultCriteria = Object.values(defaultCriteriaData).flat().some(item => item.id === itemId);
                if (isDefaultCriteria && !deletedDefaultCriteria.includes(itemId)) {
                    // This case should ideally not allow editing of default criteria's core properties
                    // other than perhaps checked state. For now, we assume it's a custom one if being edited.
                    // Or, if we allow editing default ones, we need a different update mechanism.
                    // For simplicity, assume if it's being saved via this flow, it's treated as custom or an override.
                    // This part might need refinement based on how "editing default criteria" is handled.
                     const itemIndex = (customCriteria[category] || []).findIndex(item => item.id === itemId);
                    if (itemIndex !== -1) {
                        customCriteria[category][itemIndex] = { id: itemId, name, strategies: validStrategies, risk, reward, info };
                    } else { // If not in custom, it might be a default one being "customized"
                        if (!customCriteria[category]) customCriteria[category] = [];
                        customCriteria[category].push({ id: itemId, name, strategies: validStrategies, risk, reward, info });
                        // If it was a default one, mark it as "deleted" from default to avoid duplication if we reset
                        if (!deletedDefaultCriteria.includes(itemId)) deletedDefaultCriteria.push(itemId);
                    }
                } else {
                    const itemIndex = (customCriteria[category] || []).findIndex(item => item.id === itemId);
                    if (itemIndex !== -1) {
                        customCriteria[category][itemIndex] = { id: itemId, name, strategies: validStrategies, risk, reward, info };
                    } else { // If not found, it's a new custom criteria being added via "edit" somehow (should not happen)
                         if (!customCriteria[category]) customCriteria[category] = [];
                         customCriteria[category].push({ id: itemId, name, strategies: validStrategies, risk, reward, info });
                    }
                }
            }


            saveState();
            updateChecklistState();
            closeAddEditCriteriaModal();
            showModal("Success", `Criteria "${name}" updated!`, null, null, false, true);
        }


        /**
         * Adds or updates CSS rules for a given strategy ID and color.
         * Prevents duplicate style tags on subsequent loads/updates.
         * @param {string} strategyId The ID of the strategy.
         * @param {string} color The CSS color value (hex or linear-gradient).
         */
        function addStrategyCSS(strategyId, color) {
            let style = document.getElementById(`style-${strategyId}`);
            if (!style) {
                style = document.createElement('style');
                style.id = `style-${strategyId}`;
                document.head.appendChild(style);
            }
            style.textContent = `.strategy-badge.${strategyId} { background: ${color}; }`;
        }
        
        /**
         * Updates criteria items after a strategy has been deleted.
         * Removes the deleted strategy from criteria's data-strategies attribute.
         * If a criteria has no strategies left, it's removed from the DOM and `customCriteria`.
         * @param {string} deletedStrategyId The ID of the strategy that was deleted.
         */
        function updateCriteriaAfterStrategyDelete(deletedStrategyId) {
            for (const category in customCriteria) {
                customCriteria[category] = customCriteria[category].filter(item => {
                    item.strategies = item.strategies.filter(s => s !== deletedStrategyId);
                    return item.strategies.length > 0; 
                });
                if (customCriteria[category].length === 0) {
                    delete customCriteria[category];
                }
            }

            document.querySelectorAll(`.checklist-item input[data-strategies*="${deletedStrategyId}"]`).forEach(input => {
                const currentStrategies = input.getAttribute('data-strategies').split(',').filter(s => s !== deletedStrategyId);
                if (currentStrategies.length > 0) {
                    input.setAttribute('data-strategies', currentStrategies.join(','));
                    const badges = input.parentElement.querySelector('.strategy-badges');
                    updateBadgeDisplay(badges, currentStrategies);
                } else {
                    input.parentElement.remove();
                }
            });
            updateChecklistState();
        }
        
        /**
         * Updates the display of strategy badges for a given checklist item.
         * @param {HTMLElement} badgesContainer The div element containing the badges.
         * @param {Array<string>} strategiesList An array of strategy IDs to display.
         */
        function updateBadgeDisplay(badgesContainer, strategiesList) {
            badgesContainer.innerHTML = ''; 
            strategiesList.forEach(strategyId => {
                const strategy = strategies[strategyId] || customStrategies[strategyId]; 
                if (strategy) {
                    const badge = document.createElement('span');
                    badge.className = `strategy-badge ${strategyId}`;
                    badge.textContent = strategy.name;
                    if (strategy.color.startsWith('linear-gradient')) {
                         badge.style.background = strategy.color;
                    } else {
                        badge.style.backgroundColor = strategy.color;
                    }
                    badgesContainer.appendChild(badge);
                }
            });
        }

        /**
         * Recreates all criteria elements in the DOM, respecting the categoryOrder.
         */
        function recreateAllCriteriaElements() {
            const checkedIds = Array.from(document.querySelectorAll('.input:checked')).map(input => input.id);
            const checklistContainer = document.querySelector('.checklist-container');
            
            // Temporarily detach action buttons and filter details to re-append them later
            const actionButtons = checklistContainer.querySelector('.action-buttons');
            const filterDetails = checklistContainer.querySelector('.filter-details');
            if(actionButtons) actionButtons.remove();
            if(filterDetails) filterDetails.remove();

            // Remove all existing category divs
            checklistContainer.querySelectorAll('.category').forEach(item => item.remove());

            // Re-add categories based on the categoryOrder array
            categoryOrder.forEach(categoryId => {
                if (categories[categoryId]) { 
                    const categoryData = categories[categoryId];
                    addCategoryDivToDOM(categoryId, categoryData.name, categoryData.icon, categoryData.isDefault);
                }
            });
            
            // Re-append action buttons and filter details at the top
            if(filterDetails) checklistContainer.prepend(filterDetails); // Filters below actions
            if(actionButtons) checklistContainer.prepend(actionButtons); // Actions at the very top


            // Populate categories with their criteria (default and custom)
            categoryOrder.forEach(categoryId => {
                if (defaultCriteriaData[categoryId]) {
                    defaultCriteriaData[categoryId].forEach(item => {
                        if (!deletedDefaultCriteria.includes(item.id)) {
                            createCustomCriteriaElement(categoryId, item.id, item.name, item.strategies, item.risk, item.reward, item.info);
                        }
                    });
                }
                if (customCriteria[categoryId]) {
                    customCriteria[categoryId].forEach(item => {
                        createCustomCriteriaElement(categoryId, item.id, item.name, item.strategies, item.risk, item.reward, item.info);
                    });
                }
            });

            checkedIds.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.checked = true;
                }
            });

            document.querySelectorAll(".input").forEach(input => {
                input.removeEventListener("change", updateChecklistState);
                input.removeEventListener("change", saveState);
                input.addEventListener("change", updateChecklistState);
                input.addEventListener("change", saveState);
            });
            document.querySelectorAll('label[data-info]').forEach(label => {
                label.removeEventListener('mouseover', showTooltip);
                label.removeEventListener('mouseout', hideTooltip);
                label.addEventListener('mouseover', showTooltip);
                label.addEventListener('mouseout', hideTooltip);
            });
        }


        /**
         * Creates a new category div in the DOM if it doesn't exist, or updates its header.
         * Appends it to the main checklist container.
         * @param {string} categoryId The ID of the category.
         * @param {string} name The display name of the category.
         * @param {string} icon The emoji icon for the category.
         * @param {boolean} isDefault Whether this is a default category.
         * @returns {HTMLElement} The created or existing category div.
         */
        function addCategoryDivToDOM(categoryId, name, icon, isDefault) {
            let categoryDiv = document.querySelector(`.category[data-group="${categoryId}"]`);
            const checklistContainer = document.querySelector('.checklist-container'); 

            if (!categoryDiv) {
                categoryDiv = document.createElement('div');
                categoryDiv.className = `category ${isDefault ? '' : 'custom-criteria'}`; 
                categoryDiv.setAttribute('data-group', categoryId);
                categoryDiv.setAttribute('draggable', true); 

                categoryDiv.innerHTML = `
                    <h3>
                        <div class="category-header">
                            <span class="category-icon">${icon}</span>${name}
                        </div>
                        <button class="add-criteria-mini" onclick="openAddCriteriaModal('${categoryId}')" title="Add criteria to ${name}">+</button>
                    </h3>
                `;
                
                categoryDiv.addEventListener('dragstart', handleDragStart);
                categoryDiv.addEventListener('dragend', handleDragEnd);
                
                // Find the correct place to insert based on categoryOrder, if possible,
                // or just append if it's a new category not yet in order (will be fixed on next save/load).
                // For simplicity during initial creation, we append. Order is primarily enforced by recreateAll.
                checklistContainer.appendChild(categoryDiv);

            } else {
                const header = categoryDiv.querySelector('.category-header');
                if (header) {
                    header.innerHTML = `<span class="category-icon">${icon}</span>${name}`;
                }
                categoryDiv.setAttribute('draggable', true); 
            }
            return categoryDiv;
        }


        /**
         * Creates a custom criteria element and appends it to the correct category div.
         * @param {string} categoryId The ID of the category to append to.
         * @param {string} itemId The unique ID for the criteria input.
         * @param {string} name The display name of the criteria.
         * @param {Array<string>} strategiesAn An array of strategy IDs.
         * @param {number} risk The risk value.
         * @param {number} reward The reward value.
         * @param {string} info The tooltip information.
         */
        function createCustomCriteriaElement(categoryId, itemId, name, itemStrategies, risk, reward, info) { // Renamed strategies to itemStrategies
            let categoryDiv = document.querySelector(`.category[data-group="${categoryId}"]`);
            if (!categoryDiv) {
                const categoryData = categories[categoryId] || { name: categoryId.charAt(0).toUpperCase() + categoryId.slice(1).replace('-', ' '), icon: '❓', isDefault: false };
                categoryDiv = addCategoryDivToDOM(categoryId, categoryData.name, categoryData.icon, categoryData.isDefault);
            }

            const existingItem = document.getElementById(itemId);
            if (existingItem) {
                const labelElement = existingItem.nextElementSibling;
                const badgesContainer = existingItem.parentElement.querySelector('.strategy-badges');
                labelElement.textContent = name;
                existingItem.setAttribute('data-strategies', itemStrategies.join(','));
                existingItem.setAttribute('data-risk', risk);
                existingItem.setAttribute('data-reward', reward);
                if (info) {
                    labelElement.setAttribute('data-info', info);
                } else {
                    labelElement.removeAttribute('data-info');
                }
                updateBadgeDisplay(badgesContainer, itemStrategies);
                return;
            }

            const itemDiv = document.createElement('div');
            itemDiv.className = 'checklist-item';
            itemDiv.innerHTML = `
                <input type="checkbox" class="input" data-tag="${categoryId}" id="${itemId}" data-strategies="${itemStrategies.join(',')}" data-risk="${risk}" data-reward="${reward}">
                <label for="${itemId}" ${info ? `data-info="${info}"` : ''}>${name}</label>
                <div class="strategy-badges"></div>
                <button class="edit-criteria-btn" onclick="openEditCriteriaModal('${itemId}', '${categoryId}')" title="Edit this criteria">✏️</button>
                <button class="delete-criteria-btn" onclick="deleteCriteria('${itemId}', '${categoryId}')" title="Delete this criteria">x</button>
            `;
            // Append to the category div, not the main checklist container
            categoryDiv.appendChild(itemDiv);


            updateBadgeDisplay(itemDiv.querySelector('.strategy-badges'), itemStrategies);

            const newCheckbox = itemDiv.querySelector(`#${itemId}`);
            newCheckbox.addEventListener('change', updateChecklistState);
            newCheckbox.addEventListener('change', saveState);

            const newLabel = itemDiv.querySelector(`label[for="${itemId}"]`);
            if (info) {
                newLabel.addEventListener('mouseover', showTooltip);
                newLabel.addEventListener('mouseout', hideTooltip);
            }
        }

        /**
         * Deletes a criteria from the DOM and customCriteria object.
         * If it's a default criteria, its ID is added to `deletedDefaultCriteria`.
         * @param {string} itemId The ID of the criteria to delete.
         * @param {string} categoryId The category the item belongs to.
         */
        function deleteCriteria(itemId, categoryId) {
            showModal(
                "Confirm Deletion",
                "Are you sure you want to delete this criteria? This cannot be undone.",
                () => { // onConfirm
                    const itemElement = document.getElementById(itemId);
                    if (itemElement && itemElement.parentElement) {
                        itemElement.parentElement.remove(); 

                        const isDefault = Object.values(defaultCriteriaData).flat().some(item => item.id === itemId);
                        if (isDefault) {
                            if (!deletedDefaultCriteria.includes(itemId)) {
                                deletedDefaultCriteria.push(itemId); 
                            }
                        } else {
                            if (customCriteria[categoryId]) {
                                customCriteria[categoryId] = customCriteria[categoryId].filter(item => item.id !== itemId);
                                if (customCriteria[categoryId].length === 0 && categories[categoryId] && !categories[categoryId].isDefault) { // Check if category exists before accessing isDefault
                                    // No need to delete from `categories` here, only from `customCriteria`
                                    // The category div removal is handled by recreateAllCriteriaElements if it becomes truly empty
                                    // For now, just ensure customCriteria[categoryId] is cleaned up.
                                    // If it's an empty custom category, it might visually disappear if it has no criteria.
                                    // The actual category definition in `categories` persists until explicitly deleted via Manage Categories.
                                    // delete customCriteria[categoryId]; // This was too aggressive, let recreate handle visual emptiness
                                }
                            }
                        }
                        saveState();
                        updateChecklistState();
                        showModal("Success", "Criteria deleted successfully!", null, null, false, true);
                    }
                },
                () => { /* onCancel - do nothing */ },
                true
            );
        }


        /**
         * updateChecklistState the checked criteria and updates the trade setup result.
         */
        function updateChecklistState() {
            const allInputs = document.querySelectorAll('.input:checked');
            const checkedItems = Array.from(allInputs);
            
            let totalRisk = 0;
            let totalReward = 0;

            if (checkedItems.length === 0) {
                updateResult("Select criteria to identify your trade setup...", "waiting");
                updateRiskRewardDisplay(0, 0); 
                document.getElementById('calculated-risk').textContent = 'N/A';
                document.getElementById('calculated-reward').textContent = 'N/A';
                document.getElementById('suggested-stop').textContent = 'Based on selected criteria';
                document.getElementById('suggested-target').textContent = 'Based on selected criteria';
                updatePnLDisplay(0, 0); 
                return;
            }

            let strategyCounts = {};
            let hasLevels = false;
            let hasVolumeOrTape = false;

            Object.keys(strategies).forEach(key => strategyCounts[key] = 0);
            Object.keys(customStrategies).forEach(key => strategyCounts[key] = 0);

            checkedItems.forEach(input => {
                const inputStrategiesAttr = input.getAttribute('data-strategies');
                const group = input.getAttribute('data-tag');
                
                if (group === 'levels') hasLevels = true;
                if (group === 'volume' || group === 'tape') hasVolumeOrTape = true;
                
                const strategyList = inputStrategiesAttr ? inputStrategiesAttr.split(',') : [];
                strategyList.forEach(strategy => {
                    const trimmedStrategy = strategy.trim();
                    if (strategyCounts.hasOwnProperty(trimmedStrategy)) {
                        strategyCounts[trimmedStrategy]++;
                    }
                });

                const risk = parseFloat(input.getAttribute('data-risk')) || 0;
                const reward = parseFloat(input.getAttribute('data-reward')) || 0;
                totalRisk += risk;
                totalReward += reward;
            });

            let dominantStrategy = '';
            let maxCount = 0;
            let ties = [];
            
            Object.entries(strategyCounts).forEach(([strategy, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    dominantStrategy = strategy;
                    ties = [strategy];
                } else if (count === maxCount && count > 0) {
                    ties.push(strategy);
                }
            });

            let tradeType = "";
            let resultClass = "ready";
            
            if (!hasLevels) {
                updateResult("⚠️ Missing Level Analysis - Add price level criteria", "warning");
                updateRiskRewardDisplay(totalRisk, totalReward);
                updatePnLDisplay(0, 0); 
                return;
            }
            
            if (!hasVolumeOrTape) {
                updateResult("⚠️ Missing Volume/Tape Analysis - Add market flow criteria", "warning");
                updateRiskRewardDisplay(totalRisk, totalReward);
                updatePnLDisplay(0, 0); 
                return;
            }

            if (ties.length > 1 && !ties.includes('both')) {
                const tiedNames = ties.map(s => {
                    const strategy = strategies[s] || customStrategies[s];
                    return `${strategy.icon} ${strategy.name}`;
                }).join(' + ');
                tradeType = `⚖️ Mixed Setup: ${tiedNames}`;
                resultClass = "warning";
            } else if (dominantStrategy && dominantStrategy !== 'both') {
                const strategy = strategies[dominantStrategy] || customStrategies[dominantStrategy];
                tradeType = `${strategy.icon} ${strategy.name} Setup Ready`;
            } else if (dominantStrategy === 'both') {
                tradeType = "⚖️ Multi-Strategy Setup";
            } else {
                tradeType = "📊 General Setup Identified";
            }

            const totalCriteria = checkedItems.length;
            if (totalCriteria >= 5) {
                tradeType += " - High Confidence";
            } else if (totalCriteria >= 3) {
                tradeType += " - Medium Confidence";
            } else {
                tradeType += " - Low Confidence";
                resultClass = "warning"; 
            }

            const activeStrategies = Object.entries(strategyCounts)
                .filter(([_, count]) => count > 0)
                .map(([strategy, count]) => {
                    const strategyObj = strategies[strategy] || customStrategies[strategy];
                    return `${strategyObj.name}: ${count}`;
                }).join(' | ');
            
            if (activeStrategies) {
                tradeType += `\n📊 Breakdown: ${activeStrategies}`;
            }

            updateResult(`✅ ${tradeType}`, resultClass);
            updateRiskRewardDisplay(totalRisk, totalReward);

            const calculatedRiskElement = document.getElementById('calculated-risk');
            const calculatedRewardElement = document.getElementById('calculated-reward');
            const suggestedStopElement = document.getElementById('suggested-stop');
            const suggestedTargetElement = document.getElementById('suggested-target');

            calculatedRiskElement.textContent = totalRisk.toFixed(2);
            calculatedRewardElement.textContent = totalReward.toFixed(2);

            calculatedRiskElement.setAttribute('data-info', `Sum of 'Risk Value' from all checked criteria.`);
            calculatedRewardElement.setAttribute('data-info', `Sum of 'Reward Value' from all checked criteria.`);


            if (dominantStrategy) {
                const strategyObj = strategies[dominantStrategy] || customStrategies[dominantStrategy];
                suggestedStopElement.textContent = strategyObj.defaultStop;
                suggestedTargetElement.textContent = strategyObj.defaultTarget;
            } else {
                suggestedStopElement.textContent = 'Based on selected criteria';
                suggestedTargetElement.textContent = 'Based on selected criteria';
            }

            calculatePnL(totalRisk, totalReward);
        }

        /**
         * Calculates potential Profit and Loss based on user inputs and checklist risk/reward.
         * @param {number} totalRisk The sum of risk values from checked criteria.
         * @param {number} totalReward The sum of reward values from checked criteria.
         */
        function calculatePnL(totalRisk, totalReward) {
            const tradeSize = parseFloat(document.getElementById('tradeSize').value);
            const tickValue = parseFloat(document.getElementById('tickValue').value);
            const futuresTickSize = parseFloat(document.getElementById('futuresTickSize').value); 
            const entryPrice = parseFloat(document.getElementById('entryPrice').value); 

            console.log('PNL Inputs (in calculatePnL):', { tradeSize, tickValue, futuresTickSize, entryPrice, totalRisk, totalReward });

            let potentialLoss = 0;
            let potentialProfit = 0;

            if (isNaN(tradeSize) || tradeSize <= 0 || isNaN(tickValue) || tickValue <= 0 || isNaN(futuresTickSize) || futuresTickSize <= 0) {
                console.log('Invalid PNL inputs detected, resetting display.');
                updatePnLDisplay(0, 0); 
                return;
            }

            if (totalRisk > 0) {
                potentialLoss = (totalRisk / futuresTickSize) * tickValue * tradeSize;
                console.log('Potential Loss Calculation:', { totalRisk, futuresTickSize, tickValue, tradeSize, potentialLoss });
            }

            if (totalReward > 0) {
                potentialProfit = (totalReward / futuresTickSize) * tickValue * tradeSize;
                console.log('Potential Profit Calculation:', { totalReward, futuresTickSize, tickValue, tradeSize, potentialProfit });
            }

            updatePnLDisplay(potentialLoss, potentialProfit, totalRisk, totalReward, tradeSize, tickValue, futuresTickSize);
        }


        /**
         * Updates the P&L display elements.
         * @param {number} loss The calculated potential loss.
         * @param {number} profit The calculated potential profit.
         * @param {number} totalRisk The total risk points from checklist.
         * @param {number} totalReward The total reward points from checklist.
         * @param {number} tradeSize The trade size.
         * @param {number} tickValue The tick value.
         * @param {number} futuresTickSize The futures tick size.
         */
        function updatePnLDisplay(loss, profit, totalRisk = 0, totalReward = 0, tradeSize = 0, tickValue = 0, futuresTickSize = 0) {
            const potentialLossElement = document.getElementById('potentialLoss');
            const potentialProfitElement = document.getElementById('potentialProfit');

            console.log('updatePnLDisplay called with (final values):', { loss, profit });

            potentialLossElement.textContent = loss > 0 ? `-$${loss.toFixed(2)}` : 'N/A';
            potentialProfitElement.textContent = profit > 0 ? `+$${profit.toFixed(2)}` : 'N/A';

            potentialLossElement.className = loss > 0 ? 'loss' : '';
            potentialProfitElement.className = profit > 0 ? 'profit' : '';

            if (loss > 0) {
                potentialLossElement.setAttribute('data-info', `Calculation: (Total Risk / Futures Tick Size) * Tick Value * Trade Size\n= (${totalRisk.toFixed(2)} / ${futuresTickSize.toFixed(2)}) * ${tickValue.toFixed(2)} * ${tradeSize.toFixed(2)}\n= $${loss.toFixed(2)}`);
            } else {
                potentialLossElement.removeAttribute('data-info');
            }

            if (profit > 0) {
                potentialProfitElement.setAttribute('data-info', `Calculation: (Total Reward / Futures Tick Size) * Tick Value * Trade Size\n= (${totalReward.toFixed(2)} / ${futuresTickSize.toFixed(2)}) * ${tickValue.toFixed(2)} * ${tradeSize.toFixed(2)}\n= $${profit.toFixed(2)}`);
            } else {
                potentialProfitElement.removeAttribute('data-info');
            }

            potentialLossElement.removeEventListener('mouseover', showTooltip);
            potentialLossElement.removeEventListener('mouseout', hideTooltip);
            potentialProfitElement.removeEventListener('mouseover', showTooltip);
            potentialProfitElement.removeEventListener('mouseout', hideTooltip);

            if (loss > 0) {
                potentialLossElement.addEventListener('mouseover', showTooltip);
                potentialLossElement.addEventListener('mouseout', hideTooltip);
            }
            if (profit > 0) {
                potentialProfitElement.addEventListener('mouseover', showTooltip);
                potentialProfitElement.addEventListener('mouseout', hideTooltip);
            }
        }


        /**
         * Updates the text content and CSS class of the result display.
         * @param {string} text The text to display.
         * @param {string} className The CSS class to apply ('waiting', 'ready', 'warning').
         */
        function updateResult(text, className) {
            const result = document.getElementById("result");
            result.textContent = text;
            result.className = `result ${className}`;
        }

        /**
         * Updates the risk:reward display.
         * @param {number} totalRisk The sum of risk values from checked criteria.
         * @param {number} totalReward The sum of reward values from checked criteria.
         */
        function updateRiskRewardDisplay(totalRisk, totalReward) {
            const rrDisplay = document.getElementById('risk-reward-display');
            const rrSpan = rrDisplay.querySelector('span');

            if (totalRisk === 0 && totalReward === 0) {
                rrSpan.textContent = 'N/A';
                rrDisplay.className = 'risk-reward-display'; 
            } else if (totalRisk === 0) {
                rrSpan.textContent = '∞'; 
                rrDisplay.className = 'risk-reward-display';
            } else {
                const ratio = (totalReward / totalRisk).toFixed(2);
                rrSpan.textContent = `1:${ratio}`;
                if (ratio >= 2) { 
                    rrDisplay.className = 'risk-reward-display'; 
                } else {
                    rrDisplay.className = 'risk-reward-display bad-ratio'; 
                }
            }
        }


        /**
         * Dynamically creates and updates the strategy filter buttons.
         */
        function createFilterButtons() {
            const filterContainer = document.getElementById('strategy-filters');
            filterContainer.innerHTML = ''; 

            const allButton = document.createElement('button');
            allButton.className = `filter-button ${currentFilter === 'all' ? 'active' : ''}`;
            allButton.textContent = 'All Strategies';
            allButton.onclick = () => applyStrategyFilter('all');
            filterContainer.appendChild(allButton);

            for (const id in strategies) {
                if (id !== 'both') { 
                    const button = document.createElement('button');
                    button.className = `filter-button ${currentFilter === id ? 'active' : ''}`;
                    button.textContent = `${strategies[id].icon} ${strategies[id].name}`;
                    button.onclick = () => applyStrategyFilter(id);
                    filterContainer.appendChild(button);
                }
            }

            for (const id in customStrategies) {
                const button = document.createElement('button');
                button.className = `filter-button ${currentFilter === id ? 'active' : ''}`;
                button.textContent = `${customStrategies[id].icon} ${customStrategies[id].name}`;
                button.onclick = () => applyStrategyFilter(id);
                filterContainer.appendChild(button);
            }
        }

        /**
         * Applies a filter to the checklist items based on strategy.
         * Only shows items tagged with the specified strategy or all items if 'all' is selected.
         * @param {string} filterStrategyId  The ID of the strategy to filter by, or 'all'.
         */
        function applyStrategyFilter(filterStrategyId) {
            currentFilter = filterStrategyId; 
            createFilterButtons(); 

            document.querySelectorAll('.checklist-item').forEach(item => {
                const input = item.querySelector('.input');
                if (!input) return; // Skip if item doesn't have an input (e.g. headers in modals)
                
                const itemStrategies = input.getAttribute('data-strategies') ? input.getAttribute('data-strategies').split(',') : [];
                
                if (filterStrategyId === 'all') {
                    item.style.display = 'flex'; 
                } else {
                    if (itemStrategies.includes(filterStrategyId) || itemStrategies.includes('both')) {
                        item.style.display = 'flex'; 
                    } else {
                        item.style.display = 'none'; 
                    }
                }
            });
        }

        // --- Dark Mode Toggle Functionality ---
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            document.getElementById('darkModeToggle').textContent = isDarkMode ? '🌙 Dark Mode' : '☀️ Light Mode';
            saveState(); 
        }

        // --- Tooltip Functionality ---
        let tooltipTimeout;
        const tooltipBox = document.getElementById('tooltipBox');

        function showTooltip(event) {
            const element = event.target;
            const infoText = element.getAttribute('data-info');

            if (infoText) {
                tooltipBox.innerHTML = infoText.replace(/\n/g, '<br>'); // Replace newlines with <br> for multiline tooltips
                tooltipBox.classList.add('visible');

                const elementRect = element.getBoundingClientRect();
                const containerRect = document.querySelector('.container').getBoundingClientRect(); 
                
                let top = elementRect.bottom + window.scrollY + 10; 
                let left = elementRect.left + window.scrollX;

                if (left + tooltipBox.offsetWidth > containerRect.right) {
                    left = containerRect.right - tooltipBox.offsetWidth - 20; 
                }
                if (left < containerRect.left) {
                    left = containerRect.left + 20; 
                }
                 // Adjust if tooltip goes off screen bottom
                if (top + tooltipBox.offsetHeight > window.innerHeight + window.scrollY) {
                    top = elementRect.top + window.scrollY - tooltipBox.offsetHeight - 10; // Position above
                     // Adjust arrow for above positioning (optional, more complex)
                }


                tooltipBox.style.top = `${top}px`;
                tooltipBox.style.left = `${left}px`;
            }
        }

        function hideTooltip() {
            tooltipBox.classList.remove('visible');
        }

        // --- Share/Import Settings Modal Functions (now integrated into Manage Layouts) ---
        const manageLayoutsModal = document.getElementById('manageLayoutsModal');
        const savedLayoutsTabButton = manageLayoutsModal.querySelector('[data-layout-tab="saved"]');
        const shareImportLayoutTabButton = manageLayoutsModal.querySelector('[data-layout-tab="share-import"]');
        const defaultLayoutTabButton = manageLayoutsModal.querySelector('[data-layout-tab="default"]');

        const savedLayoutsTabContent = document.getElementById('savedLayoutsTab');
        const shareImportLayoutTabContent = document.getElementById('shareImportLayoutTab');
        const defaultLayoutTabContent = document.getElementById('defaultLayoutTab');

        const exportSubTabButton = shareImportLayoutTabContent.querySelector('[data-sub-tab="export"]');
        const importSubTabButton = shareImportLayoutTabContent.querySelector('[data-sub-tab="import"]');
        const exportSubTabContent = document.getElementById('exportSubTab');
        const importSubTabContent = document.getElementById('importSubTab');

        const generateCodeBtnLayout = document.getElementById('generateCodeBtnLayout'); // Corrected ID
        const shareCodeOutputLayout = document.getElementById('shareCodeOutputLayout'); // Corrected ID
        const copyCodeBtnLayout = document.getElementById('copyCodeBtnLayout');       // Corrected ID
        const importCodeInputLayout = document.getElementById('importCodeInputLayout'); // Corrected ID
        const importCodeBtnLayout = document.getElementById('importCodeBtnLayout');   // Corrected ID


        function openManageLayoutsModal() {
            manageLayoutsModal.classList.remove('hidden');
            showLayoutTab('saved'); 
            
            exportSubTabButton.removeEventListener('click', handleExportSubTabClick); 
            importSubTabButton.removeEventListener('click', handleImportSubTabClick); 
            exportSubTabButton.addEventListener('click', handleExportSubTabClick);
            importSubTabButton.addEventListener('click', handleImportSubTabClick);
            
            showSubTab('export'); 
        }
        // Helper functions to avoid anonymous functions for removal
        function handleExportSubTabClick() { showSubTab('export'); }
        function handleImportSubTabClick() { showSubTab('import'); }


        function closeManageLayoutsModal() {
            manageLayoutsModal.classList.add('hidden');
            if(shareCodeOutputLayout) shareCodeOutputLayout.value = ''; 
            if(importCodeInputLayout) importCodeInputLayout.value = ''; 
        }

        function showLayoutTab(tabName) {
            manageLayoutsModal.querySelectorAll('[data-layout-tab]').forEach(btn => btn.classList.remove('active'));
            manageLayoutsModal.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none'; 
            });

            const selectedButton = manageLayoutsModal.querySelector(`[data-layout-tab="${tabName}"]`);
            let selectedContent;
            if (tabName === 'saved') selectedContent = document.getElementById('savedLayoutsTab');
            else if (tabName === 'share-import') selectedContent = document.getElementById('shareImportLayoutTab');
            else if (tabName === 'default') selectedContent = document.getElementById('defaultLayoutTab');
            
            if (selectedButton) selectedButton.classList.add('active');
            if (selectedContent) {
                selectedContent.classList.add('active');
                selectedContent.style.display = 'block'; 
            }

            if (tabName === 'saved') populateSavedLayoutsList();
            if (tabName === 'share-import') showSubTab('export'); 
        }

        function showSubTab(tabName) {
            shareImportLayoutTabContent.querySelectorAll('[data-sub-tab]').forEach(btn => btn.classList.remove('active'));
            shareImportLayoutTabContent.querySelectorAll('.sub-tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none'; 
            });

            const selectedButton = shareImportLayoutTabContent.querySelector(`[data-sub-tab="${tabName}"]`);
            const selectedContent = document.getElementById(`${tabName}SubTab`);

            if (selectedButton) selectedButton.classList.add('active');
            if (selectedContent) {
                selectedContent.classList.add('active');
                selectedContent.style.display = 'block'; 
            }
        }

        function generateShareCode() {
            const shareableState = {
                customStrategies: customStrategies,
                customCriteria: customCriteria,
                deletedDefaultCriteria: deletedDefaultCriteria, 
                categories: categories, 
                categoryOrder: categoryOrder, // Include category order
                checkedInputs: Array.from(document.querySelectorAll('.input:checked')).map(input => input.id)
            };
            const jsonString = JSON.stringify(shareableState);
            const compressed = LZString.compressToBase64(jsonString);
            shareCodeOutputLayout.value = compressed; // Use correct ID
            shareCodeOutputLayout.select(); 
            shareCodeOutputLayout.setSelectionRange(0, 99999); 
            showModal("Share Code Generated", "Your share code is ready. Copy it from the text area above.", null, null, false, true);
        }

        function copyShareCode() {
            shareCodeOutputLayout.select(); // Use correct ID
            shareCodeOutputLayout.setSelectionRange(0, 99999); 
            try {
                document.execCommand('copy');
                showModal("Copied!", "Share code copied to clipboard.", null, null, false, true);
            } catch (err) {
                showModal("Error", "Failed to copy code. Please copy manually.", null, null, false, true);
            }
        }

        function triggerImportSettings() {
            const encodedString = importCodeInputLayout.value.trim(); // Use correct ID
            if (!encodedString) {
                showModal("No Code", "Please paste a share code to import.", null, null, false, true);
                return;
            }

            showModal(
                "Confirm Import",
                "Are you sure you want to import these settings? This will **overwrite** your current custom strategies, custom criteria, category order, and checked items. Your notes will remain.",
                () => { // onConfirm
                    try {
                        const decompressed = LZString.decompressFromBase64(encodedString);
                        if (!decompressed) {
                            throw new Error("Decompression failed. Invalid or corrupt code.");
                        }
                        const loadedState = JSON.parse(decompressed);
                        
                        if (!loadedState || typeof loadedState.customStrategies === 'undefined' || typeof loadedState.customCriteria === 'undefined' || typeof loadedState.checkedInputs === 'undefined') {
                            throw new Error("Invalid share code structure.");
                        }

                        applyLoadedState(loadedState, true); 
                        saveState(); 
                        showModal("Import Successful!", "Your checklist has been updated with the shared settings.", null, null, false, true);
                        closeManageLayoutsModal();
                    } catch (error) {
                        console.error("Error importing settings:", error);
                        showModal("Import Failed", `Could not import settings: ${error.message || 'Invalid code.'} Please check the code and try again.`, null, null, false, true);
                    }
                },
                () => { /* onCancel - do nothing */ },
                true 
            );
        }

        // New: Layout Management Functions
        function populateSavedLayoutsList() {
            const layoutListContainer = document.getElementById('layoutListContainer');
            layoutListContainer.innerHTML = ''; 

            if (Object.keys(savedLayouts).length === 0) {
                layoutListContainer.innerHTML = '<p style="text-align: center; color: var(--modal-message-color);">No saved layouts yet.</p>';
            } else {
                for (const layoutName in savedLayouts) {
                    const layoutDiv = document.createElement('div');
                    layoutDiv.className = 'checklist-item'; 
                    layoutDiv.style.justifyContent = 'space-between';
                    layoutDiv.innerHTML = `
                        <label>${layoutName}</label>
                        <div>
                            <button class="edit-criteria-btn" onclick="loadSavedLayout('${layoutName}')" title="Load this layout">Load</button>
                            <button class="delete-criteria-btn" onclick="confirmDeleteLayout('${layoutName}')" title="Delete this layout">Delete</button>
                        </div>
                    `;
                    layoutListContainer.appendChild(layoutDiv);
                }
            }
        }

        function saveCurrentLayout() {
            showModal(
                "Save Layout",
                "Enter a name for your current layout:",
                (layoutName) => { 
                    if (layoutName && layoutName.trim() !== '') {
                        const stateToSave = {
                            checkedInputs: Array.from(document.querySelectorAll('.input:checked')).map(input => input.id),
                            customStrategies: customStrategies,
                            customCriteria: customCriteria,
                            deletedDefaultCriteria: deletedDefaultCriteria, 
                            notes: document.getElementById('trade-notes').value,
                            darkMode: document.body.classList.contains('dark-mode'),
                            tradeSize: document.getElementById('tradeSize').value,
                            tickValue: document.getElementById('tickValue').value,
                            futuresTickSize: document.getElementById('futuresTickSize').value,
                            entryPrice: document.getElementById('entryPrice').value,
                            categories: categories, 
                            categoryOrder: categoryOrder // Save category order with layout
                        };
                        savedLayouts[layoutName.trim()] = stateToSave;
                        saveState(); 
                        showModal("Success", `Layout "${layoutName}" saved!`, null, null, false, true);
                        populateSavedLayoutsList(); 
                    } else {
                        showModal("Cancelled", "Layout save cancelled or no name provided.", null, null, false, true);
                    }
                },
                () => { /* do nothing on cancel */ },
                true, 
                false, 
                { 
                    show: true,
                    label: "Layout Name:",
                    placeholder: "My Custom Layout",
                    defaultValue: ""
                }
            );
        }

        function loadSavedLayout(layoutName) {
            showModal(
                "Load Layout",
                `Are you sure you want to load "${layoutName}"? This will **overwrite** your current checklist state.`,
                () => { // onConfirm
                    const stateToLoad = savedLayouts[layoutName];
                    if (stateToLoad) {
                        applyLoadedState(stateToLoad, true); 
                        saveState(); 
                        showModal("Success", `Layout "${layoutName}" loaded!`, null, null, false, true);
                        closeManageLayoutsModal();
                    } else {
                        showModal("Error", "Layout not found.", null, null, false, true);
                    }
                },
                () => { /* onCancel - do nothing */ },
                true
            );
        }

        function confirmDeleteLayout(layoutName) {
            showModal(
                "Delete Layout",
                `Are you sure you want to delete the layout "${layoutName}"? This cannot be undone.`,
                () => { // onConfirm
                    delete savedLayouts[layoutName];
                    saveState(); 
                    showModal("Success", `Layout "${layoutName}" deleted!`, null, null, false, true);
                    populateSavedLayoutsList(); 
                },
                () => { /* onCancel - do nothing */ },
                true
            );
        }

        /**
         * Loads the default checklist layout.
         * @param {boolean} isInitialLoad Optional. If true, skips the confirmation modal.
         */
        function loadDefaultLayout(isInitialLoad = false) {
            const performLoad = () => {
                customStrategies = {}; 
                customCriteria = {}; 
                deletedDefaultCriteria = []; 
                
                categories = {
                    'levels': { name: 'Levels', icon: '📊', isDefault: true },
                    'volume': { name: 'Volume Analysis', icon: '📈', isDefault: true },
                    'timeframe': { name: 'Timeframe Alignment', icon: '⏱️', isDefault: true },
                    'oscillators': { name: 'Oscillator Signals', icon: '📊', isDefault: true },
                    'tape': { name: 'Tape Reading', icon: '📋', isDefault: true },
                    'l2': { name: 'Level 2', icon: '🎚️', isDefault: true },
                    'strategy-specific': { name: 'Strategy Specific', icon: '⭐', isDefault: true },
                    'chart-patterns': { name: 'Chart Patterns', icon: '📈', isDefault: true }
                };
                categoryOrder = Object.keys(categories); // Reset order to default

                recreateAllCriteriaElements(); 
                saveState(); 
                updateChecklistState();
                if (!isInitialLoad) { 
                    showModal("Success", "Default layout loaded!", null, null, false, true);
                }
            };

            if (isInitialLoad) {
                performLoad();
            } else {
                showModal(
                    "Load Default Layout",
                    "Are you sure you want to load the default checklist layout? This will **overwrite** your current custom strategies, custom criteria, category order, and saved layouts.",
                    performLoad, 
                    () => { /* onCancel - do nothing */ },
                    true
                );
            }
        }

        // --- New Category Management Functions ---
        function openManageCategoriesModal() {
            const categoryListContainer = document.getElementById('categoryListContainer');
            categoryListContainer.innerHTML = ''; 

            // Use categoryOrder to display categories in their current order
            categoryOrder.forEach(id => {
                if (categories[id]) { // Check if category exists
                    const category = categories[id];
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'checklist-item'; 
                    categoryDiv.innerHTML = `
                        <span class="category-icon">${category.icon}</span>
                        <label style="flex-grow: 1;">${category.name} (${id}) ${category.isDefault ? '(Built-in)' : '(Custom)'}</label>
                        <button class="edit-criteria-btn" onclick="openEditCategoryModal('${id}')" title="Edit this category">✏️</button>
                        ${!category.isDefault ? `<button class="delete-criteria-btn" onclick="confirmDeleteCategory('${id}')" title="Delete this category">x</button>` : ''}
                    `;
                    categoryListContainer.appendChild(categoryDiv);
                }
            });
            document.getElementById('manageCategoriesModal').classList.remove('hidden');
        }


        function closeManageCategoriesModal() {
            document.getElementById('manageCategoriesModal').classList.add('hidden');
            recreateAllCriteriaElements(); 
            updateChecklistState();
        }

        function openAddCategoryModal() {
            document.getElementById('addEditCategoryTitle').textContent = 'Add New Category';
            document.getElementById('categoryIdInput').value = '';
            document.getElementById('categoryIdInput').readOnly = false;
            document.getElementById('categoryNameInput').value = '';
            document.getElementById('categoryIconInput').value = '✨'; 
            document.getElementById('saveCategoryBtn').onclick = saveNewCategory;
            document.getElementById('addEditCategoryModal').classList.remove('hidden');
        }

        function openEditCategoryModal(categoryId) {
            const category = categories[categoryId];
            if (!category) {
                showModal("Error", "Category not found!", null, null, false, true);
                return;
            }
            currentEditingCategoryId = categoryId;

            document.getElementById('addEditCategoryTitle').textContent = `Edit Category: ${category.name}`;
            document.getElementById('categoryIdInput').value = categoryId;
            document.getElementById('categoryIdInput').readOnly = true; 
            document.getElementById('categoryNameInput').value = category.name;
            document.getElementById('categoryIconInput').value = category.icon;
            document.getElementById('saveCategoryBtn').onclick = saveEditedCategory;
            document.getElementById('addEditCategoryModal').classList.remove('hidden');
        }

        function closeAddEditCategoryModal() {
            document.getElementById('addEditCategoryModal').classList.add('hidden');
            currentEditingCategoryId = null;
            openManageCategoriesModal(); 
        }

        function saveNewCategory() {
            const id = document.getElementById('categoryIdInput').value.trim().toLowerCase().replace(/\s+/g, '');
            const name = document.getElementById('categoryNameInput').value.trim();
            const icon = document.getElementById('categoryIconInput').value.trim();

            if (!id || !name) {
                showModal("Validation Error", "Category ID and Display Name are required.", null, null, false, true);
                return;
            }
            if (categories[id]) {
                showModal("Validation Error", "Category ID already exists.", null, null, false, true);
                return;
            }

            categories[id] = { name, icon, isDefault: false };
            if (!categoryOrder.includes(id)) { // Add to order if not already there
                categoryOrder.push(id);
            }
            saveState();
            closeAddEditCategoryModal();
            showModal("Success", `Category "${name}" added!`, null, null, false, true);
        }

        function saveEditedCategory() {
            const id = currentEditingCategoryId;
            const name = document.getElementById('categoryNameInput').value.trim();
            const icon = document.getElementById('categoryIconInput').value.trim();

            if (!name) {
                showModal("Validation Error", "Display Name is required.", null, null, false, true);
                return;
            }

            categories[id].name = name;
            categories[id].icon = icon;
            saveState();
            closeAddEditCategoryModal();
            showModal("Success", `Category "${name}" updated!`, null, null, false, true);
        }

        function confirmDeleteCategory(categoryId) {
            const category = categories[categoryId];
            if (!category || category.isDefault) { // Also check if category exists
                showModal("Error", "Built-in categories cannot be deleted or category not found.", null, null, false, true);
                return;
            }

            showModal(
                "Confirm Deletion",
                `Are you sure you want to delete the custom category "${category.name}"? This will also delete all custom criteria within this category. This cannot be undone.`,
                () => { // onConfirm
                    delete categories[categoryId]; 
                    if (customCriteria[categoryId]) {
                        delete customCriteria[categoryId]; 
                    }
                    categoryOrder = categoryOrder.filter(id => id !== categoryId); // Remove from order
                    saveState();
                    closeManageCategoriesModal(); 
                    showModal("Success", `Category "${category.name}" and its criteria deleted!`, null, null, false, true);
                },
                () => { /* onCancel - do nothing */ },
                true
            );
        }

        // --- Drag and Drop Handlers for Categories ---
        function handleDragStart(e) {
            // Ensure the target is the category div itself, not a child element
            const categoryElement = e.target.closest('.category');
            if (!categoryElement) return;

            draggedCategoryId = categoryElement.dataset.group;
            e.dataTransfer.setData('text/plain', draggedCategoryId);
            categoryElement.classList.add('dragging'); 

            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.className = 'category-placeholder';
                placeholder.style.height = categoryElement.offsetHeight + 'px';
                placeholder.style.backgroundColor = 'rgba(0,0,0,0.1)';
                placeholder.style.border = '2px dashed #ccc';
                placeholder.style.margin = getComputedStyle(categoryElement).margin; 
                placeholder.style.borderRadius = getComputedStyle(categoryElement).borderRadius; 
            }
        }

        function handleDragEnd(e) {
            const categoryElement = e.target.closest('.category');
            if (categoryElement) {
                categoryElement.classList.remove('dragging');
            }
            if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.removeChild(placeholder);
            }
            draggedCategoryId = null;
        }
        
        function handleDragOverContainer(e) {
            e.preventDefault(); 
            if (!draggedCategoryId) return; // Only proceed if an item is being dragged

            const draggedElement = document.querySelector(`.category[data-group="${draggedCategoryId}"]`);
            if (!draggedElement) return;

            const afterElement = getDragAfterElement(e.clientY);
            const container = document.querySelector('.checklist-container');
            const actionButtons = container.querySelector('.action-buttons'); // Get action buttons to ensure placeholder isn't inserted before them

            if (afterElement == null) { // Dropping at the end
                // Ensure placeholder is not inserted before action buttons if they are at the top
                if (!container.contains(placeholder) || container.lastChild !== placeholder) {
                     container.appendChild(placeholder);
                }
            } else { // Dropping before 'afterElement'
                // Ensure placeholder is not inserted before action buttons
                if (afterElement === actionButtons || (actionButtons && actionButtons.contains(afterElement))) {
                    // If trying to drop before action buttons, append after them or at the start of categories
                    if (actionButtons && actionButtons.nextSibling) {
                        container.insertBefore(placeholder, actionButtons.nextSibling);
                    } else {
                        container.appendChild(placeholder); // Fallback
                    }
                } else if (!container.contains(placeholder) || placeholder.nextSibling !== afterElement) {
                    container.insertBefore(placeholder, afterElement);
                }
            }
        }
        
        function getDragAfterElement(y) {
            // Only consider .category elements for reordering, excluding the one being dragged and non-category elements like action buttons
            const draggableElements = [...document.querySelectorAll('.checklist-container > .category:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDropOnContainer(e) {
            e.preventDefault();
            if (!draggedCategoryId) return; // Only proceed if an item was being dragged

            const draggedElement = document.querySelector(`.category[data-group="${draggedCategoryId}"]`);
            if (!draggedElement) return;

            if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.replaceChild(draggedElement, placeholder);
            }
            
            const newOrder = [];
            const categoryElements = document.querySelectorAll('.checklist-container > .category'); // Select only direct children categories
            categoryElements.forEach(catEl => {
                newOrder.push(catEl.dataset.group);
            });
            categoryOrder = newOrder;
            saveState(); 
        }


        // --- Event Listeners for initial setup and persistence ---
        document.addEventListener("DOMContentLoaded", function () {
            loadState();

            document.getElementById('trade-notes').addEventListener('input', saveState);
            document.getElementById('darkModeToggle').addEventListener('click', toggleDarkMode);

            savedLayoutsTabButton.addEventListener('click', () => showLayoutTab('saved'));
            shareImportLayoutTabButton.addEventListener('click', () => showLayoutTab('share-import'));
            defaultLayoutTabButton.addEventListener('click', () => showLayoutTab('default'));

            // Corrected event listeners for layout share/import buttons
            if(generateCodeBtnLayout) generateCodeBtnLayout.addEventListener('click', generateShareCode);
            if(copyCodeBtnLayout) copyCodeBtnLayout.addEventListener('click', copyShareCode);
            if(importCodeBtnLayout) importCodeBtnLayout.addEventListener('click', triggerImportSettings);

            // Add dragover and drop to the main checklist container for category reordering
            const checklistContainer = document.querySelector('.checklist-container');
            if (checklistContainer) { // Ensure container exists before adding listeners
                checklistContainer.addEventListener('dragover', handleDragOverContainer);
                checklistContainer.addEventListener('drop', handleDropOnContainer);
            } else {
                console.error("Checklist container not found on DOMContentLoaded.");
            }
        });
    </script>
</body>
</html>
